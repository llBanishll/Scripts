
repeat 
	task.wait() 
until game:IsLoaded() 
	and game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") 
	and game:GetService("Players").LocalPlayer.PlayerGui.ScreenGui.LoadingMessage.Visible == false

for i,v in pairs(workspace.Decorations["Diamond Mask Hall"]:GetChildren()) do
	if v:FindFirstChild("GateScript") and v.Name == "Part" then
		v.CanTouch = false
	end
end

local getcustomasset = getsynasset or getcustomasset or function() end
local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or request or function() end 
local isfile = isfile or function(file)
	local suc, res = pcall(function() return readfile(file) end)
	return suc and res ~= nil
end


workspace.Decorations["30BeeZone"].Pit.CanTouch = false

if not LPH_OBFUSCATED then
	getgenv().LPH_NO_VIRTUALIZE = function(...) return ... end
	getgenv().LPH_JIT = function(...) return ... end 
	getgenv().LPH_STRENC = function(str) return str end
end
local std = setthreadcaps or setthreadidentity
local scriptType = LPH_STRENC("Paid")

ExploitSpecific = "ðŸ“œ"
Danger = "âš ï¸"
Star = "â­"

-- Variables
local VirtualInputManager = game:GetService('VirtualInputManager')
local PathfindingService = game:GetService('PathfindingService')
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService('UserInputService')
local TweenService = game:GetService('TweenService')
local UserService = game:GetService("UserService")
local HttpService = game:GetService('HttpService')
local VirtualUser = game:GetService('VirtualUser')
local RunService = game:GetService('RunService')
local Workspace = game:GetService('Workspace')
local Lighting = game:GetService('Lighting')
local CoreGui = game:GetService('CoreGui')
local Players = game:GetService('Players')

local RoboBear = Workspace.NPCs:WaitForChild("Robo Bear")
local dupedTokensFolder = Workspace.Camera.DupedTokens
local EventsDir = ReplicatedStorage.Events
local FlowerZones = Workspace.FlowerZones
local Flowers = Workspace.Flowers

local Activatables = ReplicatedStorage.Activatables
local MemoryMatchManager = ReplicatedStorage.MemoryMatchManager
local MemoryMatchGui = ReplicatedStorage.Gui.MemoryMatch

-- Modules
local ActivatablesHives = require(ReplicatedStorage.Activatables.Hives)
local ActivatablesToys = require(ReplicatedStorage.Activatables.Toys)
local ActivatablesNPC = require(ReplicatedStorage.Activatables.NPCs)
local ActivatablesPlanters = require(ReplicatedStorage.Activatables.Planter)

local ScreenInfo = require(ReplicatedStorage.ScreenInfo)
local Events = require(ReplicatedStorage.Events)
local Quests = require(ReplicatedStorage.Quests)
local RoboBearGui = require(game.ReplicatedStorage.Gui.RoboBearGui)

local PlanterTypes = require(ReplicatedStorage.PlanterTypes)
local NectarTypes = require(ReplicatedStorage.NectarTypes)
local EggTypes = require(ReplicatedStorage.EggTypes)
local BeeTypes = require(ReplicatedStorage.BeeTypes)

local LocalPlanters = require(ReplicatedStorage.LocalPlanters)
local Accessories = require(ReplicatedStorage.Accessories)
local Collectors = require(ReplicatedStorage.Collectors)

local checkAccessory = require(ReplicatedStorage.ItemPackages.Accessory).PlayerHas
local checkTool = require(ReplicatedStorage.ItemPackages.Collector).PlayerHas
local BuffTileModule = require(ReplicatedStorage.Gui.TileDisplay.BuffTile)
local ClientMonsterTools = require(ReplicatedStorage.ClientMonsterTools)
local MemoryMatchModule = require(ReplicatedStorage.Gui.MemoryMatch)
local ClientStatCache = require(ReplicatedStorage.ClientStatCache)
local MinigameGui = require(ReplicatedStorage.Gui.MinigameGui)
local MonsterTypes = require(ReplicatedStorage.MonsterTypes)
local timeToString = require(ReplicatedStorage.TimeString)
local AlertBoxes = require(ReplicatedStorage.AlertBoxes)
local StatTools = require(ReplicatedStorage.StatTools)
local StatReqs = require(ReplicatedStorage.StatReqs)
local ServerTime = require(ReplicatedStorage.OsTime)

local PlayerActivesCommand = ReplicatedStorage.Events.PlayerActivesCommand
local RetrievePlayerStats = ReplicatedStorage.Events.RetrievePlayerStats

local ScreenGui = ScreenInfo:GetScreenGui()




local bssapi = loadstring(game:HttpGet("https://raw.githubusercontent.com/7BioHazard/mv3/main/bssapi.lua"))()
local library
local api
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

do
	if not setreadonly then game.Players.LocalPlayer:Kick("x.synapse.to") end

	setreadonly(table, false)

	local ver = 0

	local vitaly = {}
	vitaly['generaterandomstring'] = function(a)
		local let = ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'):split('')
		local string = '' 
		for i = 1, a do 
			string = string..let[math.random(1, #let)]
		end 
		return string 
	end
	vitaly["humanoidrootpart"] = function()
		return game.Players and game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	end
	vitaly["humanoid"] = function() 
		return game.Players and game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Humanoid")
	end
	vitaly["tween"] = function(speed, pos)
		if vitaly.humanoidrootpart() then
			if typeof(pos) == "CFrame" then pos = pos.p end
			local speed = (vitaly.humanoidrootpart().Position - pos).Magnitude / speed
			game:GetService("TweenService"):Create(vitaly.humanoidrootpart(), TweenInfo.new(speed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(pos)}):Play() task.wait(speed)
		end
	end
	vitaly["walkTo"] = function(Pos)
		if mv2.humanoid() then
			mv2.humanoid():MoveTo(Pos)
		end
	end
	vitaly["isExist"] = function(obj)
		NewObjName = vitaly.generaterandomstring(10)
		oldObjName = obj and obj.Name
		obj.Name = NewObjName
		if obj ~= nil or obj.Parent:FindFirstChild(NewObjName) then
			obj.Name = oldObjName
			return true
		else
			return false
		end
	end
	vitaly["player"] = game.Players.LocalPlayer
	vitaly["notify"] = function(title, description, duration)
		pcall(function()
			game.StarterGui:SetCore("SendNotification", {
				Title = title;
				Text = description;
				Duration = duration;
			})
		end)
	end
	vitaly["isSynapse"] = function()
		if syn then
			return true
		else
			return false
		end
	end
	vitaly["isSynV3"] = function()
		local exploit = identifyexecutor and table.concat({ identifyexecutor() }, " ") or "Unknown"
		if exploit:gmatch("/") then
			exploit = exploit:split("/")[1]
		end
		if vitaly.isSynapse() and exploit:lower():match("v3") then
			return true
		end
		return false
	end
	vitaly['isKrnl'] = function()
		if Krnl then
			return true
		else
			return false
		end
	end
	vitaly['isScriptWare'] = function()
		if identifyexecutor and tostring(identifyexecutor()):match("ScriptWare") then return true end
	end
	vitaly['isFluxus'] = function()
		if identifyexecutor and tostring(identifyexecutor()):match("Fluxus") then return true end
	end
	vitaly['isElectron'] = function()
		if identifyexecutor and tostring(identifyexecutor()):match("Electron") then return true end
	end
	vitaly["isValyse"] = function()
		return Valyse and true or false
	end
	vitaly['ver'] = ver
	vitaly['magnitude'] = function(v1, v2)
		return ((v2 or vitaly.humanoidrootpart().Position) - v1).magnitude
	end
	vitaly['afunc'] = function(f)
		local wa = coroutine.create(
			function()
				f()
			end)
		coroutine.resume(wa)
	end
	vitaly["getField"] = function(part)
		part = part or vitaly.humanoidrootpart()
		local ray = Ray.new(part.Position+Vector3.new(0, -35, 0), Vector3.new(0,100, 0))
		local hit, hitPos = workspace:FindPartOnRayWithWhitelist(ray, {game.Workspace.FlowerZones})
		if hit and hit.Parent.Name == "FlowerZones" then
			return hit
		else
			return nil
		end
	end

	vitaly['tableFind'] = function(tt, va)
		for i,v in pairs(tt) do
			if v == va then
				return i
			end
		end
	end

	vitaly['findValue'] = function(Table, Value)
		if type(Table) == "table" then
			for index, value in pairs(Table) do
				if value == Value then
					return true
				end
			end
		else
			return false
		end
		return false
	end
	vitaly['returnValue'] = function(tab, val)
		ok = false
		for i,v in pairs(tab) do
			if string.match(val, v) then
				ok = v
				break
			end
		end
		return ok
	end

	do -- secure_call things
		local oldt;oldt = hookfunction(getrenv().debug.traceback, function(lol) -- prevent debug.traceback detection
			local traceback = oldt(lol)
			if checkcaller() then
				local a = traceback:split("\n")
				return string.format("%s\n%s\n", a[1], a[3])
			end
			return traceback
		end)
		local oldi;oldi = hookfunction(getrenv().debug.info, function(lvl, a) -- prevent debug.info detection
			if checkcaller() then
				return oldi(3, a)
			end
			return oldi(lvl, a)
		end)
	end

	getgenv().secureCall = function(Function, Script, ...)
		assert(Script ~= nil or typeof(Script) == "Instance", string.format("invalid argument #1 to '%s' (table expected, got %s)", "secureCall", typeof(Script)))
		assert(Function ~= nil or typeof(Function) == "function", string.format("invalid argument #2 to '%s' (table expected, got %s)", "secureCall", typeof(Function)))
		assert(Script.ClassName == "LocalScript" or Script.ClassName == "ModuleScript", string.format("bad argument to #3 to '%s' (LocalScript or ModuleScript expected, got %s)", "secureCall", Script.ClassName))

		if vitaly.isSynV3() then
			local Info = debug.getinfo(Function)
			local Options = {
				script = Script,
				identity = 2,
				env = getsenv(Script),
				thread = getscriptthread and getscriptthread(Script)
			}
			local Callstack = {Info}

			return syn.trampoline_call(Function, Callstack, Options, ...)
		elseif vitaly.isSynapse() then
			return syn.secure_call(Function, Script, ...)
		elseif vitaly.isKrnl() then
			return coroutine.wrap(function(...)
				setthreadcontext(2)
				setfenv(0, getsenv(Script))
				setfenv(1, getsenv(Script))
				return Function(...)
			end)(...)
		elseif vitaly.isScriptWare() then
			local func, env = Function, Script
			local functype, envtype = typeof(func), typeof(env)
			assert(functype == "function", string.format("bad argument #1 to 'secure_call' (function expected, got %s)", functype))
			assert(envtype == "Instance", string.format("bad argument #2 to 'secure_call' (Instance expected, got %s)", envtype))
			local envclass = env.ClassName
			assert(envclass == "LocalScript" or envclass == "ModuleScript", string.format("bad argument #2 to 'secure_call' (LocalScript or ModuleScript expected, got %s)", envclass))
			local _, fenv = xpcall(function()
				return getsenv(env)
			end, function()
				return getfenv(func)
			end)
			return coroutine.wrap(function(...)
				setidentity(2)
				setfenv(0, fenv)
				setfenv(1, fenv)
				return func(...)
			end)(...)
		elseif vitaly.isElectron() or vitaly.isFluxus() or vitaly.isValyse() then
			return coroutine.wrap(function(...)
				setthreadcontext(2)
				setfenv(0, getsenv(Script))
				setfenv(1, getsenv(Script))
				return Function(...)
			end)(...)
		else
			return coroutine.wrap(function(...) 
				(set_thread_identity or setthreadcontext)(2)
				return Function(...)
			end)(...)
		end
	end

	setreadonly(table, false)

	api = vitaly
end

local player = Players.LocalPlayer

local plantersCacheFilePath = "vitaly/plantercache/"..player.Name.."_customPlantersCache.json"
if not isfolder("vitaly") then makefolder("vitaly") end
if not isfolder("vitaly/plantercache") then makefolder("vitaly/plantercache") end
if gethui then
	for i, v in pairs(gethui():GetDescendants()) do
		if v:IsA("TextLabel") then
			if v.Name:find("vitaly") then
				v.Parent.Parent.Parent.Parent.Parent:Destroy()
			end
		end
	end
else
	for i, v in pairs(CoreGui:GetDescendants()) do
		if v:IsA("TextLabel") then
			if v.Name:find("vitaly") then
				v.Parent.Parent.Parent.Parent.Parent:Destroy()
			end
		end
	end    
end

local currentvitalyLoadedAt = tick()
getgenv().vitalyLoadedAt = currentvitalyLoadedAt

plrHive = nil
httpreq = (syn and syn.request) or http_request or (http and http.request) or request
setIdentity = (syn and syn.set_thread_identity) or setthreadcontodo or setidentity or setthreadidentity or set_thread_identity
getIdentity = (syn and syn.get_thread_identity) or getidentity or getthreadidentity or get_thread_identity
local origThreadIdentity = getIdentity and getIdentity() or 8

local Tasks = {_LIST={}}
function Tasks:Add(taskName, taskFunction, isLuraphNoVirtualize)
	local spawnedtask
	if isLuraphNoVirtualize then
		spawnedtask = task.spawn(function() 
			LPH_NO_VIRTUALIZE(function() taskFunction() end)()
		end)
	else
		spawnedtask = task.spawn(taskFunction)
	end
	if spawnedtask then
		Tasks._LIST[taskName] = spawnedtask
	end
end

function Tasks:Cancel(taskName)
	if Tasks._LIST[taskName] ~= nil then
		pcall(function()
			task.cancel(Tasks._LIST[taskName])
		end)
		Tasks._LIST[taskName] = nil 
	end
end
function Tasks:Get(taskName)
	if Tasks._LIST[taskName] ~= nil then
		return Tasks._LIST[taskName]
	end
end
function Tasks:CancelAll()
	for i,v in pairs(Tasks._LIST) do
		pcall(function() 
			task.cancel(v)
		end)
	end
end

getgenv().vitaly = {
	toggles = {
		autodispensers = false,
		autoboosters = false,
		automemorymatch = false,

		autofarm = false,
		autodig = false,
		converthiveballoon = false,
		convertHoney = true,

		autoPlanters = false,

		speedhack = false,

		autoMotherHouse = false,
		autoWealthClock = false,
		autoHoneystorm = false,
		autoFreeAntPass = false,
		autoFreeRoboPass = false,
		autoSamovar = false,
		autoStockings = false,
		autoOnettArt = false,
		autoCandles = false,
		autoFeast = false,
		autoSnowMachine = false,
		autoHoneyWreath = false,
		farmrares = false,
		AutoHoneyM = false,
		autoFireFly = false
	},
	vars = {
		equipAccessoryMethod = "Tween",
		defaultmask = "None",
		rares = {},
	},
	autoFarmSettings = {
		field = "Dandelion Field",

		autoSprinkler = true,

		farmShower = false,
		farmCoconuts = false,
		farmBubbles = false,
		farmFlames = false,
		farmUnderClouds = false,
		farmUnderBalloons = false,
		farmFuzzyBombs = false,
		farmDupedTokens = false,

		smartBubbleBloat = false,
		smartPreciseCrosshair = false,
		smartPreciseMethod = "Fast Tween "..Danger,
		ignoreHoneyTokens = false,
		farmSprouts = false,

		faceBalloons = false,
		faceFlames = false,
		faceCenter = false,
	},
	convertSettings = {
		secondsBeforeConvert = 0,
		convertat = 100,
		convertballoonat = 0,
		instantToggle = false,
		selectedInstant = {},
	},
	autodispensersettings = {
		treatDispenser = false,
		royalJellyDispenser = false,
		blueberryDispenser = false,
		strawberryDispenser = false,
		coconutDispenser = false,
		glueDispenser = false,
		freerobopass = false,
		freeantpass = false
	},
	autoboostersettings = {
		whiteBooster = false,
		redBooster = false,
		blueBooster = false
	},
	rares = {},
	autoQuestSettings = {
		doQuests = false,
		doRepeatables = true,
		acceptAllQuests = false,

		BlackBearQuests = false,
		BrownBearQuests = false,
		PandaBearQuests = false,
		ScienceBearQuests = false,
		PolarBearQuests = false,
		SpiritsBearQuests = false,
		BuckoBeeQuests = false,
		RileyBeeQuests = false,
		HoneyBeeQuests = false,
		OnettQuests = false,

		-- 
		enablePriorities = false,
		prioritizeMobKill = true,

		BlackBearPriority = 1,
		BrownBearPriority = 1,
		PandaBearPriority = 1,
		ScienceBearPriority = 1,
		PolarBearPriority = 6,
		SpiritBearPriority = 1,
		BuckoBeePriority = 1,
		RileyBeePriority = 1,
		HoneyBeePriority = 1,
		OnettPriority = 1,
		BeeBearPriority = 1,

		BeeBearQuests = false,

		farmPollen = false,
		farmGoo = false,
		killMobs = false,
		feedBees = false,
		useToys = false,
		useMemoryMatch = false,
		doQuestQuests = false,


		tpToNPC = false,
		doAnts = false,

		bestBlueField = "Pine Tree Forest",
		bestRedField = "Rose Field",
		bestWhiteField = "Pumpkin Patch"

	},
	webhookSettings = {
		useWebhook = false,
		onlyTruncated = false,
		showTotalHoney = false,
		showHoneyPerHour = false,
		showDailyHoney = false,
		showPlanters = false,
		showNectars = false,
		showItems = false,
		sendQuests = false,

		discordId = "0",
		webhookUrl = "",
		webhookColor = "0xfcdf03",
		pingUser = false,
		messageFrequency = 30,

		itemsList = {},
	},
	autoPlantersSettings = {
		doPlanters = false,
		planterHarvestAt = 20,
		doCustomPlanters = false,
		blacklistedNectars = {},
		blacklistedPlanters = {}
	},
	autoPuffshroomSettings = {
		farmPuffshrooms = false,
		farmRemaining = true,
		rarityPriority = "Mythic > Common",
		levelPriority = "High > Low",
		minimumLevel = 1,
		maximumLevel = 16
	},
	localPlayerSettings = {
		walkSpeed = 60,
		tweenSpeed = 7
	},
	combatSettings = {
		trainCrab = false,
		trainKingBeetle = false,
		trainTunnelBear = false,
		trainStumpSnail = false,
		snailConvertHoney = false,
		killVicious = false,
		viciousMinLevel = 1,
		viciousMaxLevel = 12,

		killSpidor = false,
		killMantis = false,
		killScorpion = false,
		killWerewolf = false
	},
	customPlanterSettings = {
		customPlanters1 = {
			[1] = {planter = "", field = "", harvestAmount = 75},
			[2] = {planter = "", field = "", harvestAmount = 75},
			[3] = {planter = "", field = "", harvestAmount = 75},
			[4] = {planter = "", field = "", harvestAmount = 75},
			[5] = {planter = "", field = "", harvestAmount = 75}
		},
		customPlanters2 = {
			[1] = {planter = "", field = "", harvestAmount = 75},
			[2] = {planter = "", field = "", harvestAmount = 75},
			[3] = {planter = "", field = "", harvestAmount = 75},
			[4] = {planter = "", field = "", harvestAmount = 75},
			[5] = {planter = "", field = "", harvestAmount = 75}
		},
		customPlanters3 = {
			[1] = {planter = "", field = "", harvestAmount = 75},
			[2] = {planter = "", field = "", harvestAmount = 75},
			[3] = {planter = "", field = "", harvestAmount = 75},
			[4] = {planter = "", field = "", harvestAmount = 75},
			[5] = {planter = "", field = "", harvestAmount = 75}
		},
	},
	alertSettings = {
		viciousAlert = true
	},
	RoboBearChallangeSettings = {
		autoRBC = false
	},
	raresList = {}
}


getgenv().temptable = {
	version = "0.1",
	convertingHoney = false,
	stopAll = false,
	activeMemoryMatch = nil,

	honeyAtStart = ClientStatCache.Get(nil,{"Totals", "Honey"}),
	lastWebhookSent = 0,

	tokenpath = Workspace.Collectibles,
	fieldDecosFolder = Workspace:FindFirstChild("FieldDecos") or ReplicatedStorage:FindFirstChild("FieldDecos"),
	lastWalkToNearest = 0,

	fieldSelected,
	fieldPosition,
	floversRow = {},

	customWalkSpeed = {enabled = false, speed = 50},

	plantingPlanter = false,

	detected = {
		vicious = false,
		windy = false
	},

	doingShower = false,
	doingMonster = false,
	doingTokens = false,

	stopAutofarm = false,

	autoRJSettings = {
		requireGifted = false,
		requireAnyGifted = false,
		xCoord = 3,
		yCoord = 1,
		runningAutoRJ = false,
		selectedBees = {},
		selectedRarities = {}
	},
	showersTable = {},
	coconutsTable = {},
	lastShowerRegistered = 0,

	sproutsTable = {},
	susTokenPositions = {},

	leafTable = {},
	sparklesTable = {},
	balloonsTable = {},

	FieldBalloons = nil,

	codesTable = {
		"Wax",
		"Roof",
		"Nectar",
		"Crawlers",
		"Connoisseur",
		"Cog",
		"Buzz",
		"Bopmaster",
		"38217",
		"GumdropsForScience",
		"ClubConverters",
		"BeesBuzz123",
		"PlushFriday",
	}, codesActivated = false,

	stopEverything = false,

	puffsDetected = false,
	popStarActive = false,

	lastConvertAtHive = 0,
	lastFullBag = 0,

	MConverterUsedAt = 0,
	IConverterUsedAt = 0,

	tokensTable = {},
	lastTweenToRare = 0,

	selectedPriorityNpc = "Black Bear",
	npcPrioLabel = nil,
	npcPrioSlider = nil,

	autoRBC = {
		isActive = false,
		isUnlocked = nil,
		latestRBC = 0
	},

	questUseItemCooldown = false,
	questFeedCooldown = false,
	questUseToyCooldown = false,

	dupedTokensTable = {},
	EquippedCollector = "Not loaded"
}

local cocoPad = Instance.new("Part")
cocoPad.Position = Workspace.Territories.CoconutTerritory.Position + Vector3.new(0,15,0)
cocoPad.Size = Workspace.Territories.CoconutTerritory.Size * Vector3.new(1,0,1) + Vector3.new(0,1,0)
cocoPad.Anchored = true
cocoPad.CanCollide = false
cocoPad.Transparency = 1
cocoPad.Parent = Workspace

local tunnelPart = Instance.new("Part")
tunnelPart.Anchored = true
tunnelPart.CanCollide = true
tunnelPart.Position = Vector3.new(410, 27, -48)
tunnelPart.Size = Vector3.new(10,1,10)
tunnelPart.Transparency = 1
tunnelPart.Parent = Workspace
Workspace.Decorations.TrapTunnel["Tunnel Ceiling"].CanCollide = false

if not Workspace:FindFirstChild("Cave") then
	local CaveFolder = Instance.new("Folder", Workspace)
	CaveFolder.Name = "Cave"

	local FillPart = Instance.new("Part", CaveFolder)
	FillPart.Name = "FillPart"
	FillPart.Position = Vector3.new(-29.765, 70.252, -144)
	FillPart.Size = Vector3.new(149.529, 10.607, 89.198)
	FillPart.Transparency = 1
end

function removeFromTable(Table, element)
	return table.remove(Table, table.find(Table, element))
end

function getTweenSpeed()
	return (vitaly.localPlayerSettings.tweenSpeed * 10) or 70
end

function bssAlert(style, text)
	secureCall(AlertBoxes.Push, player.PlayerScripts.AlertBoxes, nil, text, nil, style)
end

function checkCave(startPos, endPos)
	local direction = (endPos - startPos).Unit
	local ray = Ray.new(startPos, direction * (endPos - startPos).magnitude)
	local part = Workspace:FindPartOnRayWithWhitelist(ray, {Workspace.Cave})
	if part then return true else return false end
end

getgenv().TweenNoclip = nil
function stopTween()
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoidRootPart = character.PrimaryPart
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")

	if getgenv().TweenNoclip then 
		pcall(function() TweenNoclip:Disconnect() end) 
		TweenNoclip = nil 
	end

	if humanoidRootPart then
		for i,v in pairs(humanoidRootPart:GetChildren()) do
			if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
				v:Destroy()
			end
		end
	end

	if humanoid then humanoid:ChangeState(Enum.HumanoidStateType.Freefall) end
end

function tween(pos, speed, caveAvoid)
	local character = player.Character or player.CharacterAdded:Wait()
	local humanoid = character:WaitForChild("Humanoid")
	local humanoidRootPart = character.PrimaryPart
	local b = false
	if checkCave(humanoidRootPart.Position, pos) and not caveAvoid then
		tween(Vector3.new(8, 90, -140), speed, true)
		character = player.Character or player.CharacterAdded:Wait()
		humanoid = character:WaitForChild("Humanoid")
		humanoidRootPart = character.PrimaryPart
	end

	stopTween()
	local fixedSpeed = false
	if speed then fixedSpeed = true end

	local alignPos = Instance.new("AlignPosition")
	alignPos.Mode = Enum.PositionAlignmentMode.OneAttachment
	alignPos.Attachment0 = humanoidRootPart.RootAttachment
	alignPos.MaxForce = math.huge
	alignPos.MaxVelocity = (fixedSpeed and speed) or getTweenSpeed()
	alignPos.Position = pos
	alignPos.Parent = humanoidRootPart

	local alignOrientation = Instance.new("AlignOrientation")
	alignOrientation.Attachment0 = humanoidRootPart.RootAttachment
	alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
	alignOrientation.RigidityEnabled = true
	alignOrientation.CFrame = humanoidRootPart.CFrame
	alignOrientation.Parent = humanoidRootPart

	-- humanoid:ChangeState(Enum.HumanoidStateType.Landed)
	-- task.wait()
	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	getgenv().TweenNoclip = RunService.PostSimulation:Connect(function()
		for _, part in character:GetDescendants() do
			if part:IsA("BasePart") and part.CanCollide then
				part.CanCollide = false
			end
		end
	end)

	local startTimestamp = tick()
	local playerDied = false
	local a = humanoid.Died:Connect(function() 
		playerDied = true
	end)

	local tempNoClip = getgenv().TweenNoclip

	repeat 
		task.wait()
		if not fixedSpeed then
			alignPos.MaxVelocity = getTweenSpeed()
		end
	until 
	player:DistanceFromCharacter(pos) <= 5
		or tempNoClip ~= getgenv().TweenNoclip 
		or playerDied
		or (tick() - startTimestamp) > 30

	a:Disconnect()
	if playerDied then
		stopTween()
		warn("ok1")
		player.CharacterAdded:Wait()
		task.wait(0.5)
		if caveAvoid then return end
		return false, tween(pos, speed)
	end

	if (tick() - startTimestamp) > 45 then 
		error("[Macro V3] (%s) | An error has occurred: %s"):format(temptable.version, "Tween timed out.") 
	end

	if tempNoClip == TweenNoclip then
		return true, stopTween()
	end

	return false
end

function startTween(pos, speed)
	local tweenCompleted = nil
	coroutine.wrap(function() 
		tweenCompleted = pcall(function() 
			tween(pos, speed)
		end)
		if tweenCompleted == nil then tweenCompleted = false end
	end)()
	repeat task.wait() until tweenCompleted ~= nil
end

getgenv().moveTo = function(pos)
	startTween(pos + Vector3.new(0,3,0))
end

function jsonEncode(tbl)
	local jsonString
	pcall(function() jsonString = HttpService:JSONEncode(tbl) end)
	return jsonString
end

function jsonDecode(json)
	local luaTable
	local a,s = pcall(function() luaTable = HttpService:JSONDecode(json) end)
	return luaTable
end

function getPartsFromRay(ray, whitelist)
	if typeof(whitelist) == "Instance" then whitelist = whitelist:GetDescendants() 
	elseif typeof(whitelist) == "nil"  then whitelist = {} end

	local Parts = {}
	local LastPart

	repeat
		LastPart = workspace:FindPartOnRayWithIgnoreList(ray, Parts)
		table.insert(Parts, LastPart)
	until LastPart == nil

	for i,v in pairs(Parts) do
		if not table.find(whitelist, v) then table.remove(Parts, i) continue end
	end

	return Parts
end

function walkTo(pos, timeout)
	timeout = timeout or 30
	local startedWalking = tick()
	local walkFinished = false
	player.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
	api.humanoid():MoveTo(pos)
	local walkFinishedSignal = api.humanoid().MoveToFinished:Connect(function() walkFinished = true end)

	repeat 
		task.wait()
	until walkFinished or (tick() - startedWalking) > timeout
	pcall(function() walkFinishedSignal:Disconnect() end)
	api.humanoid():MoveTo(api.humanoidrootpart().Position)
	player.DevComputerMovementMode = Enum.DevComputerMovementMode.UserChoice
	return walkFinished
end

while not player:FindFirstChild("Honeycomb") do 
	for i = 8,3,-1 do
		local hive = Workspace.Honeycombs:FindFirstChild("Hive"..i)
		if hive and not hive.Owner.Value then
			repeat
				if api.magnitude(hive.SpawnPos.Value.p, api.humanoidrootpart().Position) < 10 then
					secureCall(ActivatablesHives.ButtonEffect, Activatables, player, hive.Platform.Value)

					task.wait(.75)
				else 
					moveTo(hive.SpawnPos.Value.p - Vector3.new(0,2,0))
				end
				task.wait()
			until hive.Owner.Value or player:FindFirstChild("Honeycomb")
			if player:FindFirstChild("Honeycomb") then break end
		end
	end
end

plrHive = player:FindFirstChild("Honeycomb").Value

function isBeesmas()
	local active = Workspace:WaitForChild"Toys":FindFirstChild"Beesmas Tree" and true

	return active
end


function findField(position)
	local ray = Ray.new(position+Vector3.new(0, -35, 0), Vector3.new(0,100, 0))
	local hit, hitPos = workspace:FindPartOnRayWithWhitelist(ray, {game.Workspace.FlowerZones})
	if hit and hit.Parent.Name == "FlowerZones" then
		return hit
	else
		return nil
	end
end

function getNumbers(str)
	local nums = {}
	for num in str:gmatch("%d+") do
		table.insert(nums, tonumber(num))
	end
	return nums
end

function truncate(num)
	num = tonumber(math.round(num))
	if num <= 0 then
		return 0
	end
	local savenum = ""
	local i = 0
	local suff = ""
	local suffixes = {"k","M","B","T","qd","Qn","sx","Sp","O","N"}
	local length = math.floor(math.log10(num)+1)
	while num > 999 do
		i = i + 1
		suff = suffixes[i] or "???"
		num = num/1000
		savenum = (math.floor(num*100)/100)..suff
	end
	if i == 0 then
		return num
	end
	return savenum
end

function truncatetime(sec)
	local second = tostring(sec%60)
	local minute = tostring(math.floor(sec / 60 - math.floor(sec / 3600) * 60))
	local hour = tostring(math.floor(sec / 3600))

	return (#hour == 1 and "0"..hour or hour)..":"..(#minute == 1 and "0"..minute or minute)..":"..(#second == 1 and "0"..second or second)
end

function pressButton(button)
	VirtualInputManager:SendKeyEvent(true, button, false, game)
	game:GetService("RunService").Heartbeat:Wait()
	VirtualInputManager:SendKeyEvent(false, button, false, game)
end

function addcommas(num)
	local str = tostring(num):reverse():gsub("(%d%d%d)", "%1,"):reverse()
	if str:sub(1,1) == "," then
		str = str:sub(2)
	end
	return str
end

function getTokenId(token)
	local id = "0"
	if token and token.Parent and token:FindFirstChildOfClass("Decal") then
		local texture = token:FindFirstChildOfClass("Decal").Texture
		local tempId = tonumber(tostring(texture):match("%d+"))
		if tempId then id = tempId end
	end
	return id
end

local accessoryShopsLocations = {
	["Diamond Mask Shop"] = Vector3.new(-335, 132, -391),
	["Demon Mask Shop"] = Vector3.new(297, 27, 274),
	["Master Shop"] = Vector3.new(-486, 69, 0)
}

local accessoryShops = {
	["Diamond Mask"] = accessoryShopsLocations["Diamond Mask Shop"],
	["Demon Mask"] = accessoryShopsLocations["Demon Mask Shop"],
	["Honey Mask"] = accessoryShopsLocations["Master Shop"]
}

function remoteEquipAccessory(accessory)
	Events.ClientCall("ItemPackageEvent", "Equip", {
		Mute = false,
		Type = accessory,
		Category = "Accessory"
	})
end

function requestAccessoryEquip(accessory)
	local shopPosition = accessoryShops[accessory]
	if not shopPosition then
		return false, "Invalid input!"
	end

	local accessoryType = accessoriesTable[accessory]
	if not accessoryType then
		return false, "Accessory not found!"
	end


	if not checkAccessory({Type = accessory}, getClientStatCache()) then 
		return false, "Player does not have "..accessory
	end

	local currentAccessory = updateClientStatCache("EquippedAccessories", accessoryType)


	if currentAccessory == accessory then
		return false, "Already equipped " .. accessory
	end

	if vitaly.vars.equipAccessoryMethod == "Tween" then
		moveTo(shopPosition)
	elseif vitaly.vars.equipAccessoryMethod == "Teleport" then
		api.humanoidrootpart().CFrame = CFrame.new(shopPosition)
	end

	task.wait(0.1)
	if (api.magnitude(shopPosition) < 25) or vitaly.vars.equipAccessoryMethod == "Remote" then
		remoteEquipAccessory(accessory)
		return true
	else
		return false
	end
end

function getRandomRareToken()
	for i=#temptable.tokensTable, 1, -1 do
		local token = temptable.tokensTable[i]
		if not token or not token.Parent then continue end

		local tokenId = tostring(getTokenId(token))
		if table.find(vitaly.vars.raresList, tokenId) then
			return token
		end
	end
end

function getMinePlanters()
	local minePlantersTable = {}
	pcall(function()
		local plantedPlanters = debug.getupvalues(LocalPlanters.LoadPlanter)[4]
		for i, v in pairs(plantedPlanters) do
			if v.IsMine and v.PotModel and v.Active and not v.Collected then
				table.insert(minePlantersTable,v)
			end
		end
	end)
	return minePlantersTable
end

function updateClientStatCache(...)
	return ClientStatCache:Update({...})
end

function getClientStatCache(...)
	return ClientStatCache:Get({...})
end

function getDailyHoney()
	return ClientStatCache.GetDailyTotal(nil, "Honey") - (ClientStatCache.GetDailyTotal(nil, "ChallengeHoney") - (ClientStatCache.GetDailyTotal(nil, {"EggsReceived","SysHoney"})))
end

function getWarningDisks()
	local warningDisks = {}
	for i,v in pairs(game.Workspace.Particles:GetChildren()) do
		if v.Name == "WarningDisk" or v.Name == "Thorn" then 
			table.insert(warningDisks,v) 
		end
	end
	return warningDisks
end

if _G.debugging then
	warn("Tables init.")
end

--Tables

local npcIconsEndpoint = "https://static.wikia.nocookie.net/bee-swarm-simulator/images/"
local npcsIcons = {
	["Polar Bear"]   = npcIconsEndpoint.."2/23/Polar.png",
	["Bucko Bee"]    = npcIconsEndpoint.."3/3d/GiftedBuckoBeeNPCTransparent.png",
	["Black Bear"]   = npcIconsEndpoint.."7/71/Black.png",
	["Mother Bear"]  = npcIconsEndpoint.."a/af/MotherBearTrans.png",
	["Brown Bear"]   = npcIconsEndpoint.."0/06/Brown.png",
	["Panda Bear"]   = npcIconsEndpoint.."0/00/Panda.png",
	["Science Bear"] = npcIconsEndpoint.."a/a5/Science.png",
	["Dapper Bear"]  = npcIconsEndpoint.."4/4b/DapperBear.png",
	["Spirit Bear"]  = npcIconsEndpoint.."2/21/Spirit_bear333.png",
	["Riley Bee"]    = npcIconsEndpoint.."b/b0/GiftedRileyBeeNPCTransparent.png"
}

local miscEmojis = {
	["Polar Power"] = "<:PolarPower:1080979354030444594>"
}

local nectarEmojis = {
	["Refreshing Nectar"]   = "<:Refreshing:1080956994070007818>",
	["Invigorating Nectar"] = "<:Invigorating:1080967902800392354>",
	["Comforting Nectar"]   = "<:Comforting:1080968750888652960>",
	["Motivating Nectar"]   = "<:Motivating:1080969173536096357>",
	["Satisfying Nectar"]   = "<:Satisfying:1080969460288073748>"
}

local plantersEmojis = {
	["Paper Planter"]         = "<:PaperPlanter:1084965375965405265>",
	["Plastic Planter"]       = "<:PlasticPlanter:1084965381711597598>",
	["Candy Planter"]         = "<:CandyPlanter:1084965368147226716>",
}

AllToysTable = {
	["toysTable"] = {
		['autoWealthClock'] = "Wealth Clock",
		['autoHoneystorm'] = "Honeystorm",
		['autoFreeAntPass'] = "Free Ant Pass Dispenser",
		['autoFreeRoboPass'] = "Free Robo Pass Dispenser"
	},
	["boostersTable"] = {
		['whiteBooster'] = 'Field Booster',
		['redBooster'] = 'Red Field Booster',
		['blueBooster'] = 'Blue Field Booster'
	},
	["dispensersTable"] = {
		['treatDispenser'] = "Treat Dispenser",
		['royalJellyDispenser'] = "Free Royal Jelly Dispenser",
		['blueberryDispenser'] = "Blueberry Dispenser",
		['strawberryDispenser'] = "Strawberry Dispenser",
		['coconutDispenser'] = "Coconut Dispenser",
		["glueDispenser"] = "Glue Dispenser"
	},
	["memoryMatchTable"] = {}
}

if isBeesmas() then
	AllToysTable["beesmasToysTable"] = {
		['autoSamovar'] = "Samovar",
		['autoStockings'] = "Stockings",
		['autoOnettArt'] = "Onett's Lid Art",
		['autoCandles'] = "Honeyday Candles",
		['autoFeast'] = "Beesmas Feast",
		['autoSnowMachine'] = "Snow Machine",
		['autoHoneyWreath'] = "Honey Wreath"
	}
	AllToysTable["toysTable"]["autoMotherHouse"] = "Gingerbread House"
end

fieldsTable = {}
blueFields = {}
redFields = {}
whiteFields = {}

monstersTable = {}
plantersTable = {}
plantersDropdownTable = {}
nectarsTable = {}
accessoriesTable = {}

sproutRarities = {
	[Color3.fromRGB(103,162,201)] = "Moon",
	[Color3.fromRGB(180, 190, 186)] = "Common",

}

showerTable = {}
beesTable = {namesOnly = {}, fullData = {}, raritiesTable = {"Any Common", "Any Rare", "Any Epic", "Any Legendary", "Any Mythic"}}
npcsTable = {"Black Bear", "Brown Bear", "Panda Bear", "Science Bear", "Polar Bear", "Spirit Bear", "Bucko Bee", "Riley Bee", "Honey Bee", "Onett", "Bee Bear 5"}

nectarsDropdownTable = {
	"Comforting Nectar",
	"Satisfying Nectar",
	"Invigorating Nectar",
	"Refreshing Nectar",
	"Motivating Nectar"
}

if _G.debugging then
	warn("Tables init done. Waiting 1 second")
	task.wait(1)
end

if _G.debugging then
	warn("Tables init 2.")
end

--Tables init
for fieldIndex, field in pairs(Workspace.FlowerZones:GetChildren()) do
	table.insert(fieldsTable, field.Name)
	if not field:FindFirstChild("ColorGroup") then
		local colorGroup = Instance.new("StringValue")
		colorGroup.Name = "ColorGroup"
		colorGroup.Value = "White"
		colorGroup.Parent = field
	end
	if field.ColorGroup.Value == "Blue" then table.insert(blueFields, field.Name)
	elseif field.ColorGroup.Value == "Red" then table.insert(redFields, field.Name)
	elseif field.ColorGroup.Value == "White" then table.insert(whiteFields, field.Name)
	end
end

for i,v in pairs(Accessories.GetTypes()) do
	if v.Slot then
		accessoriesTable[i] = v.Slot
	end
end

for i,v in pairs(PlanterTypes.GetTypes()) do
	if v.Description == "Test planter." or i == "Ticket" or i == "Festive" then continue end
	local planterData = {
		systemName = v.Name,
		displayName = v.DisplayName,
		nectarMultipliers = v.NectarMultipliers,
		pollenMultipliers = v.PollenMultipliers
	}
	plantersTable[v.Name] = planterData
	table.insert(plantersDropdownTable, v.DisplayName)
end

writefile("newPlanters.json", game.HttpService:JSONEncode(plantersTable))

for i,v in pairs(NectarTypes.GetTypes()) do
	nectarsTable[i] = v.Fields
end

for i,v in pairs(temptable.tokenpath:GetChildren()) do
	table.insert(temptable.susTokenPositions, v.Position)
end


for i,v in pairs(Workspace.MonsterSpawners:GetChildren()) do
	monstersTable[v.Name] = {RespawnCooldown = 0, MonsterType = nil}
	monstersTable[v.Name].MonsterType = v.MonsterType.Value
	monstersTable[v.Name].RespawnCooldown = MonsterTypes.Get(v.MonsterType.Value).Stats.RespawnCooldown
	monstersTable[v.Name].Spawner = v
	if v.Name == "WerewolfCave" then
		monstersTable[v.Name].Territory = v.Territory.Value.w
	elseif v.Name == "MushroomBush" then
		monstersTable[v.Name].Territory = v.Territory.Value.Part
	else
		monstersTable[v.Name].Territory = v.Territory.Value
	end
end

for i,v in pairs(Workspace.Toys:GetChildren()) do
	if v.Name:find("Memory Match") then table.insert(AllToysTable["memoryMatchTable"], v.Name) end
end

for i,v in pairs(require(game:GetService("ReplicatedStorage").BeeTypes).GetTypes()) do
	table.insert(beesTable.namesOnly, i.." Bee")
	beesTable.fullData[i] = {Rarity = v.Rarity}
end

if _G.debugging then
	warn("Tables init 2. Waiting 1 second")
	task.wait(1)
end

--Functions

function markAsCollected(object)
	local collectedCache = Instance.new("Folder")
	collectedCache.Name = "Collected"
	collectedCache.Parent = object
end

local cachedFieldFlowers = {}

function getAllFlowers(field)
	local fieldId = field.ID.Value
	local fieldFlowers
	if cachedFieldFlowers[field.Name] then
		fieldFlowers = cachedFieldFlowers[field.Name]
	else
		fieldFlowers = {}
		for flowerIndex, flower in pairs(Workspace.Flowers:GetChildren()) do
			local flowerInfo = getNumbers(flower.Name)
			if #flowerInfo == 3 and flowerInfo[1] == fieldId then
				table.insert(fieldFlowers, flower)
			end
		end
		if not (#fieldFlowers <= 1) then 
			cachedFieldFlowers[field.Name] = fieldFlowers 
		else
			return 
		end
	end
	return fieldFlowers
end

function getRandomFlower(field)
	local fieldId = field.ID.Value
	local fieldFlowers
	if cachedFieldFlowers[field.Name] then
		fieldFlowers = cachedFieldFlowers[field.Name]
	else
		fieldFlowers = {}
		for flowerIndex, flower in pairs(Workspace.Flowers:GetChildren()) do
			local flowerInfo = getNumbers(flower.Name)
			if #flowerInfo == 3 and flowerInfo[1] == fieldId then
				table.insert(fieldFlowers, flower)
			end
		end
		if not (#fieldFlowers <= 1) then 
			cachedFieldFlowers[field.Name] = fieldFlowers 
		else
			return 
		end
	end
	return fieldFlowers[math.random(1,#fieldFlowers)]
end

local cachedFieldCenters = {farm = {}, sprinkler = {}}

function getNewFarmCenter(field, sprinkler)
	if not (field:FindFirstChild("ColorGroup") and field.ColorGroup.Value == "Blue") then return end
	if sprinkler and cachedFieldCenters["sprinkler"][field.Name] then 
		return cachedFieldCenters["sprinkler"][field.Name] 
	elseif not sprinkler and cachedFieldCenters["farm"][field.Name] then
		return cachedFieldCenters["farm"][field.Name] 
	end
	local flowers = getAllFlowers(field)
	local minX = math.huge
	local minY = math.huge
	local maxX = -math.huge
	local maxY = -math.huge

	for i, flower in ipairs(flowers) do
		local flowerSettings = getNumbers(flower.Name)
		minX = math.min(minX, flowerSettings[2])
		minY = math.min(minY, flowerSettings[3])
		maxX = math.max(maxX, flowerSettings[2])
		maxY = math.max(maxY, flowerSettings[3])
	end

	local flowerCenter 
	if maxX - minX >= maxY - minY then -- x is longer
		local centerFlowerX = sprinkler and maxX - 5 or maxX
		local centerFlowerY = sprinkler and maxY - 5 or maxY --math.floor((minY + maxY) / 2 + 0.5)
		for i,v in pairs(flowers) do
			if v.Name == "FP"..field.ID.Value.."-"..centerFlowerX.."-"..centerFlowerY then
				flowerCenter = v
				break
			end
		end
	else -- y is longer
		local centerFlowerX = sprinkler and maxX - 5 or maxX --math.floor((minX + maxX) / 2 + 0.5)
		local centerFlowerY = sprinkler and maxY - 5 or maxY
		for i,v in pairs(flowers) do
			if v.Name == "FP"..field.ID.Value.."-"..centerFlowerX.."-"..centerFlowerY then
				flowerCenter = v
				break
			end
		end
	end
	if flowerCenter then
		if sprinkler and not cachedFieldCenters["sprinkler"][field.Name] then 
			cachedFieldCenters["sprinkler"][field.Name] = flowerCenter
		elseif not sprinkler and not cachedFieldCenters["farm"][field.Name] then
			cachedFieldCenters["farm"][field.Name] = flowerCenter
		end
	end
	return flowerCenter
end



function jump()
	if not player.Character.Humanoid.Jump then
		player.Character.Humanoid.Jump = true
	end
end

function getPlanterData(planterName)
	local planterData
	if plantersTable[planterName] then 
		planterData = plantersTable[planterName] 
	else
		for i,v in pairs(plantersTable) do
			if v.displayName == planterName then
				planterData = v
				break
			end
		end
	end
	return planterData
end

function gethiveballoon()
	for _,balloon in pairs(Workspace.Balloons.HiveBalloons:GetChildren()) do
		if balloon:FindFirstChild("BalloonRoot") then
			if balloon.BalloonRoot.CFrame.p.X == player.SpawnPos.Value.p.X then
				return true
			end
		end
	end
	return false
end

function getBuffTime(buffName, convertToHMS)
	local buff = BuffTileModule.GetBuffTile(buffName)
	if not buff or not buff.TimerDur or not buff.TimerStart then 
		return 0 
	end

	local toReturn = buff.TimerDur - (math.floor(ServerTime()) - buff.TimerStart)
	if convertToHMS then 
		toReturn = timeToString(toReturn) 
	end

	return toReturn
end

function getBuffStack(buffName)
	local buff = BuffTileModule.GetBuffTile(buffName)

	return (buff and tostring(buff.Combo)) or 0
end

function getCurrentTime()
	local CurrentTime = Lighting.ClockTime
	return (CurrentTime > 10 and "Day") or "Night"
end

function disableall()
	temptable.disableAll = true
end

function enableall()
	temptable.disableAll = false
end

function isFieldSame(pos1, pos2)
	return findField(pos1) == findField(pos2)
end

if _G.debugging then
	warn("Functions init.")
end

function canTaskBeSpawned(taskName)
	if taskName == "getToys" then
		if temptable.puffsDetected and vitaly.autoPuffshroomSettings.farmPuffshrooms then return false end

		return true
	elseif taskName == "farmPlanters" then
		if temptable.puffsDetected and vitaly.autoPuffshroomSettings.farmPuffshrooms then return false end

		return true
	elseif taskName == "killVicious" then

		return true
	elseif taskName == "trainBosses" then
		if temptable.puffsDetected and vitaly.autoPuffshroomSettings.farmPuffshrooms then return false end

		return true
	end
end

function canCollectToken(token)
	return 
		token.Parent and 
		((api.humanoidrootpart().Position * Vector3.new(0,1,0)) - (token.Position * Vector3.new(0,1,0))).magnitude < 6 and
		token.CFrame.YVector.Y == 1
end

function canFarmTask(taskName) 
	if taskName == "getNearestBubble" and vitaly.autoFarmSettings.farmBubbles  
		or taskName == "getNearestFuzz" and vitaly.autoFarmSettings.farmFuzzyBombs  
		or taskName == "getNearestCloud" and vitaly.autoFarmSettings.farmUnderClouds  
		or taskName == "getNearestFlame" and vitaly.autoFarmSettings.farmFlames  
		or taskName == "getNearestToken" and true
	then return true else return false end
end
function dig()
	std(2)
	require(game.ReplicatedStorage.Collectors.LocalCollect).Run()
	std(8)
end
local NearestTable = {}

NearestTable.getNearestBubble = function(callback)
	local nearest = {bubble = nil, distance = math.huge}
	for _,bubble in pairs(Workspace.Particles:GetChildren()) do
		if bubble.Name ~= "Bubble" then continue end
		if callback and not callback(bubble) then continue end
		local distance = api.magnitude(bubble.Position)
		if distance < nearest.distance then
			nearest = {bubble = bubble, distance = distance}
		end
	end
	return nearest.bubble, nearest.distance
end

NearestTable.getNearestFuzz = function(callback)
	local nearest = {fuzz = nil, distance = math.huge}
	for _,fuzz in pairs(Workspace.Particles:GetChildren()) do
		if fuzz.Name ~= "DustBunnyInstance" then continue end
		if callback and not callback(fuzz.Plane) then continue end
		local distance = api.magnitude(fuzz.Plane.Position)
		if distance < nearest.distance then
			nearest = {fuzz = fuzz.Plane, distance = distance}
		end
	end
	return nearest.fuzz, nearest.distance
end

NearestTable.getNearestToken = function(blacklistedTokens, callback)
	local nearest = {token = nil, distance = math.huge}
	for _, token in ipairs(temptable.tokenpath:GetChildren()) do
		if blacklistedTokens and table.find(blacklistedTokens, token) then warn("Token blacklisted") continue end
		if callback and not callback(token) then continue end
		if canCollectToken(token) then
			local distance = api.magnitude(token.Position)
			if distance < nearest.distance then
				nearest = {token = token, distance = distance}
			end
		end
	end
	return nearest.token, nearest.distance
end

NearestTable.getNearestCloud = function(callback)
	local nearest = {cloud = nil, distance = math.huge}
	for _, cloud in ipairs(Workspace.Clouds:GetChildren()) do
		if not cloud:FindFirstChild("Plane") then continue end
		if callback and not callback(cloud.Plane) then continue end
		local distance = api.magnitude(cloud.Plane.Position)
		if distance < nearest.distance then
			nearest = {cloud = cloud.Plane, distance = distance}
		end
	end
	return nearest.cloud, nearest.distance
end

NearestTable.getNearestFlame = function(callback)
	local nearest = {flame = nil, distance = math.huge}
	for _, flame in ipairs(Workspace.PlayerFlames:GetChildren()) do
		if not flame:FindFirstChild("PF") or flame:FindFirstChild("PF") and flame.PF.Color.Keypoints[1].Value.G == 0 then continue end
		if callback and not callback(flame) then continue end
		local distance = api.magnitude(flame.Position)
		if distance < nearest.distance then
			nearest = {flame = flame, distance = distance}
		end
	end
	return nearest.flame, nearest.distance
end

getNearestBalloon = function(callback) 
	local nearest = {token = nil, distance = math.huge}
	for _, balloon in pairs(temptable.balloonsTable) do
		if callback and not callback(balloon.BalloonBody) then continue end
		if not balloon:FindFirstChild("BalloonBody") then continue end
		local distance = api.magnitude(balloon.BalloonBody.Position)
		if distance < nearest.distance then
			nearest = {balloon = balloon.BalloonBody, distance = distance}
		end
	end
	return nearest.balloon, nearest.distance
end

function getNearestTask(callback)
	local nearest = {taskName = "", distance = math.huge, object = nil}
	local distanceTable = {}
	for i, v in pairs(NearestTable) do
		if not canFarmTask(i) then continue end

		if i ~= "getNearestToken" then
			local temp = string.gsub(i, "getNearest", "")
			local Name = tostring(temp)
			local values = {v(callback)}
			local tableToAdd={Name, i, values[1], values[2]}
			table.insert(distanceTable, tableToAdd)
		else
			local temp = string.gsub(i, "getNearest", "")
			local Name = tostring(temp)
			local values = {v(nil, callback)}
			local tableToAdd={Name, i, values[1], values[2]}
			table.insert(distanceTable, tableToAdd)
		end
	end
	for i, v in pairs(distanceTable) do
		if v[4] < nearest.distance then
			nearest = {taskName = v[1], distance = v[4], object = v[2]}
		end
	end
	return nearest.taskName, nearest.object
end

function farmNearest(callback)
	local nearestName = getNearestTask(callback)
	if nearestName == "Bubble" then
		return farmBubble(callback)
	elseif nearestName == "Token" then
		return farmToken(callback)
	elseif nearestName == "Fuzz" then
		return farmFuzzy(callback)
	end
	return false
end

function getTokenLink()
	local nearestTokenLink = {token = nil, distance = math.huge}
	for _,token in ipairs(temptable.tokenpath:GetChildren()) do
		if getTokenId(token) == 1629547638 and token.CFrame.YVector.Y == 1 and not token:FindFirstChild("Collected") then
			local distance = (token.Position - player.Character.HumanoidRootPart.Position).magnitude
			if distance < nearestTokenLink.distance then
				nearestTokenLink = {token = token, distance = distance}
			end
		end
	end
	return nearestTokenLink.token
end

function collectToken(token)
	if not token.Parent or token:FindFirstChild("Collected") then return false end
	local startedCollecting = tick()
	local moveToCalled = -1
	local collected = false
	while true do
		if (api.humanoidrootpart().Position - token.Position).magnitude < 4 or
			token.CFrame.YVector.Y ~= 1 or
			not workspace:FindPartOnRay(Ray.new(api.humanoidrootpart().Position, token.Position - api.humanoidrootpart().Position)) or
			(token.Position - api.humanoidrootpart().Position).magnitude < 4 or
			(tick() - startedCollecting) >= 3
		then
			if (tick() - startedCollecting) >= 3 then break end
			collected = true
			break
		elseif (api.humanoidrootpart().Position - token.Position).magnitude > 200 then break end

		if tick() - moveToCalled > 0.25 then
			if (tick() - temptable.lastTweenToRare) < 5 then break end
			if not pcall(function()
					api.humanoid():MoveTo(token.Position)
				end) then break end
			moveToCalled = tick()
		end

		task.wait()
	end
	if collected then
		markAsCollected(token)
		return true
	else
		return false
	end
end

function farmToken(customCallback)
	local nearestTokenLink = getTokenLink()
	if nearestTokenLink then
		collectToken(nearestTokenLink)
		return true
	else
		local tokenToCollect = NearestTable.getNearestToken(nil, function(token)
			if customCallback and not customCallback(token) then 
				return false
			end
			if token.CFrame.YVector.Y == 1 and not token:FindFirstChild("Collected") and not table.find(temptable.susTokenPositions, token.Position) then 
				return true 
			end 
		end)
		if not tokenToCollect then return end
		collectToken(tokenToCollect)
		return true
	end
end

function farmBubble(customCallback)
	local nearestBubble = NearestTable.getNearestBubble(function(bubble)
		if not bubble or customCallback and not customCallback(bubble) then 
			return false
		end    
		if not bubble:FindFirstChild("Collected") then return true end
	end)
	if not nearestBubble then return false end

	local startedCollecting = tick()
	local moveToCalled = -1

	while true do
		if api.magnitude(nearestBubble.Position) < 8.5 or
			not nearestBubble.Parent or
			(tick() - startedCollecting) >= 8 then
			break
		end

		if tick() - moveToCalled > 0.5 then
			api.humanoid():MoveTo(nearestBubble.Position)
			moveToCalled = tick()
		end

		RunService.Heartbeat:Wait()
	end

	markAsCollected(nearestBubble)
	return true
end

function farmFuzzy(customCallback) --Sakata Jump Delete if you see this
	local nearestFuzz = NearestTable.getNearestFuzz(function(fuzz)
		if customCallback and not customCallback(fuzz) then 
			return false
		end    
		if not fuzz:FindFirstChild("Collected") then return true end
	end)
	if not nearestFuzz then return false end

	local startedCollecting = tick()
	local moveToCalled = -1

	while true do
		if api.magnitude(nearestFuzz.Position) < 8.5 or
			not nearestFuzz.Parent or
			(tick() - startedCollecting) >= 8 then
			break
		end

		if tick() - moveToCalled > 0.5 then
			api.humanoid():MoveTo(nearestFuzz.Position)
			moveToCalled = tick()
		end

		RunService.Heartbeat:Wait()
	end

	markAsCollected(nearestFuzz)
	return true
end

function farmCoco() --will be added after priority system

end

function farmFire()  --will be added after priority system

end

function farmCloud()  --will be added after priority system

end

-- Sort items and tokens to make it easier to use
local Items = EggTypes.GetTypes()

local FormattedItems = {FullData = {}, NamesOnly = {}}

EggItems = {}

task.spawn(function()
	for i,v in pairs(Items) do
		if not v.Hidden then
			if v.DisplayName then
				local succ = pcall(function() HttpService:JSONEncode(v) end)
				if not succ then continue end
				v["SystemName"] = i
				FormattedItems["FullData"][v.DisplayName] = v
				table.insert(FormattedItems["NamesOnly"], v.DisplayName)
				table.insert(EggItems, v.DisplayName)
			end
		end
	end
	for i,v in pairs(ReplicatedStorage.Collectibles:GetChildren()) do
		if v:IsA("ModuleScript") then
			if v:FindFirstChild("Icon") then
				FormattedItems["FullData"][v.Name] = {Icon = tostring(v.Icon.Texture)}
				table.insert(FormattedItems["NamesOnly"], v.Name)
				if v:FindFirstChild("IconPlus") then
					FormattedItems["FullData"][v.Name.."Plus"] = {DisplayName = v.Name, Icon = tostring(v.IconPlus.Texture)}
					table.insert(FormattedItems["NamesOnly"], v.Name.."Plus")
				end
			end
		end
	end
	for i,v in pairs(ReplicatedStorage.Buffs:GetChildren()) do
		if v.Name:find("Icon") then
			local tokenName = v.Name:gsub(" Icon", "")
			FormattedItems["FullData"][tokenName] = {DisplayName = tokenName, Icon = tostring(v.Texture)}
			table.insert(FormattedItems["NamesOnly"], tokenName)
		end
	end
end)

function getItemByName(name)
	if not table.find(FormattedItems["NamesOnly"],tostring(name)) then return nil, tostring(name).." not found in the NamesOnly list" end
	for i,v in pairs(FormattedItems["FullData"]) do
		if v.DisplayName == name then
			return v
		end
	end
	return nil, "Not found full data of "..name
end

function gotoNearestBalloon(waitForMoveFinish)
	local semiFarmed = false
	local balloon = getNearestBalloon(function(balloon) 
		if balloon and balloon.Parent and balloon:FindFirstChild("BalloonBody") and isFieldSame((temptable.fieldSelected and temptable.fieldSelected.Position or api.humanoidrootpart().Position), balloon.BalloonBody.Position - Vector3.new(0,15,0)) then return true end
	end)
	if balloon and balloon:FindFirstChild("BalloonBody") and api.magnitude(balloon.BalloonBody.Position) > 10 then
		api.humanoid():MoveTo(balloon.BalloonBody.Position)
		if waitForMoveFinish then
			local startMove = tick()
			repeat task.wait() until api.magnitude(balloon.BalloonBody.Position) < 6 or (tick() - startMove) > 1
			semiFarmed = true
		else
			task.wait()
		end
	end
	return semiFarmed
end

local puffsRarityList = {
	Common = 1,
	Rare = 2,
	Epic = 3,
	Legendary = 4,
	Mythic = 5
}

function checkPuffshrooms()
	local puffFound = false
	if #Workspace.Happenings.Puffshrooms:GetChildren() > 0 then
		puffFound = true
	else
		for i,v in pairs(Workspace.Particles:GetChildren()) do
			if v.Name == "SporeCloud" then
				puffFound = true
				break
			end
		end
	end
	temptable.puffsDetected = puffFound
	return puffFound
end

function checkPopStar()
	if not Workspace.Particles:FindFirstChild("PopStars") then return false end
	local popStarFound = false
	for i,v in pairs(Workspace.Particles.PopStars:GetChildren()) do
		if (player.Character.HumanoidRootPart.Position - v.Position).magnitude < 13
			and getBuffTime("Pop Star Aura") > 0 then
			popStarFound = true
			break 
		end
	end
	temptable.popStarActive = popStarFound
	return popStarFound
end

-- function checkLeafsAndSparkles()
--     local leafTable = {}
--     for _, flower in ipairs(Flowers:GetChildren()) do
--         if flower:FindFirstChild("LeafBurst") then
--             table.insert(leafTable, flower)
--         elseif flower:FindFirstChild("Sparkles")then
--             table.insert(sparklesTable, flower)
--         end
--     end
--     temptable.leafTable = leafTable
--     return leafTable
-- end

function getBestFieldBalloon()
	if not api.humanoidrootpart() then return warn(1) end
	local humanoidRootPart = api.humanoidrootpart()

	local bestFieldBalloon = {instance = nil, mostBalloonsInRow = -1}

	for _,balloon in pairs(temptable.balloonsTable) do
		if not balloon:FindFirstChild("BalloonBody") then continue end
		local playerPos = humanoidRootPart.Position + Vector3.new(0,16,0)
		local balloonPos = balloon.BalloonBody.Position

		if not isFieldSame(playerPos - Vector3.new(0,16,0), balloonPos - Vector3.new(0,16,0)) then continue end

		local __, res = pcall(function()  
			if balloon.BalloonBody.GuiAttach.Gui.Bar.BackgroundTransparency ~= 1 then return true end
		end)
		if res ~= true then warn(isOK, res) continue end

		local ray = Ray.new(playerPos, (Vector3.new(balloonPos.X, playerPos.Y, balloonPos.Z) - playerPos))

		local intersection = getPartsFromRay(ray, temptable.FieldBalloons)

		if intersection and #intersection >= bestFieldBalloon.mostBalloonsInRow then
			bestFieldBalloon.mostBalloonsInRow = #intersection
			bestFieldBalloon.instance = balloon
		end
	end

	return bestFieldBalloon.instance
end

function getPuffsOnField(field)
	local puffsOnField = {}
	for i,v in pairs(Workspace.Happenings.Puffshrooms:GetChildren()) do
		if findField(v.PrimaryPart.Position) == field then
			table.insert(puffsOnField, v)
		end
	end
	return puffsOnField
end

function getBestPuffshroom()
	local puffs = Workspace.Happenings.Puffshrooms:GetChildren()
	if #puffs == 0 then return nil end
	local bestPuffs = {}

	local maxRarity = vitaly.autoPuffshroomSettings.rarityPriority == "Mythic > Common" and 0 or 6

	for i, puff in ipairs(puffs) do
		local puffName
		pcall(function()
			puffName = puff["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
		end)
		if not puffName then warn("No puff name") return {} end
		local puffRarity = string.match(puffName, "(%a*)%s+Puffshroom") or "Common"
		local puffLevel = tonumber(string.match(puffName, "Lvl (%d+)"))
		if not tonumber(puffLevel)
			or not puffLevel 
			or tonumber(puffLevel) < vitaly.autoPuffshroomSettings.minimumLevel
			or tonumber(puffLevel) > vitaly.autoPuffshroomSettings.maximumLevel 
			or not puff:FindFirstChild("Puffball Stem")
			or not findField(puff["Puffball Stem"].Position)
		then continue end
		local rarityValue = puffsRarityList[puffRarity] or 1

		if (vitaly.autoPuffshroomSettings.rarityPriority == "Mythic > Common" and rarityValue > maxRarity) or
			(vitaly.autoPuffshroomSettings.rarityPriority == "Common > Mythic" and rarityValue < maxRarity) then
			maxRarity = rarityValue
			bestPuffs = { puff }
		elseif rarityValue == maxRarity then
			table.insert(bestPuffs, puff)
		end
	end

	table.sort(bestPuffs, function(a, b)
		local aName = a["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
		local aRarity, aLevel = string.match(aName, "(%a*)%s+Puffshroom") or "Common", tonumber(string.match(aName, "Lvl (%d+)"))

		local bName = b["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
		local bRarity, bLevel = string.match(bName, "(%a*)%s+Puffshroom") or "Common", tonumber(string.match(bName, "Lvl (%d+)"))
		-- local aRarity, aLevel = a.Name:match("(%a*)%s+Puffshroom%s+%(%a*%s*(%d+)%)")
		-- local bRarity, bLevel = b.Name:match("(%a*)%s+Puffshroom%s+%(%a*%s*(%d+)%)")
		aLevel, bLevel = tonumber(aLevel), tonumber(bLevel)
		local aRarityValue, bRarityValue = puffsRarityList[aRarity] or 1, puffsRarityList[bRarity] or 1
		if aRarityValue == bRarityValue then
			if vitaly.autoPuffshroomSettings.levelPriority == "High > Low" then
				return aLevel > bLevel
			else
				return aLevel < bLevel
			end
		else
			if vitaly.autoPuffshroomSettings.rarityPriority == "Mythic > Common" then
				return aRarityValue > bRarityValue
			else
				return aRarityValue < bRarityValue
			end
		end
	end)

	local bestPuff = bestPuffs[1]
	-- print(bestPuff["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text)
	if bestPuff then
		local puffName = bestPuff["Puffball Top"].Attachment.Gui.NameRow.TextLabel.Text
		local puffRarity = string.match(puffName, "(%a*)%s+Puffshroom") or "Common"
		local puffLevel = tonumber(string.match(puffName, "Lvl (%d+)"))
		return { Rarity = puffRarity, Level = tonumber(puffLevel), Model = bestPuff }
	end

	return nil
end

function farmPuffshroom(puffToFarm)
	local farmed = false
	local stem = puffToFarm.PrimaryPart
	if stem and puffToFarm.Parent == Workspace.Happenings.Puffshrooms then
		local stemPos = stem.Position
		if not isFieldSame(api.humanoidrootpart().Position, stemPos) then
			moveTo(stemPos)
		end
		placeSprinkler(stemPos, true, true)
		while task.wait() and puffToFarm.Parent == Workspace.Happenings.Puffshrooms and vitaly.autoPuffshroomSettings.farmPuffshrooms and vitaly.toggles.autofarm do
			if getBagPercentage() >= 99 then return false, "Bag is full" end
			if not isFieldSame(api.humanoidrootpart().Position, stemPos) then
				moveTo(stemPos)
			elseif api.magnitude(stemPos) >= 20 then
				task.wait()
				local temp1 = nil
				task.spawn(function() temp1 = walkTo(stemPos, 0.5) end)
				repeat task.wait() until temp1 ~= nil
			elseif api.magnitude(stemPos) < 20 then
				collectNearestTokens(stemPos, 30)
				task.wait()
			else
				moveTo(stemPos)
			end
			farmed = true
		end
		if farmed and puffToFarm.Parent ~= Workspace.Happenings.Puffshrooms and vitaly.toggles.autofarm and vitaly.autoPuffshroomSettings.farmPuffshrooms then
			task.wait(0.5)
			for i=1,2 do
				collectNearestTokens()
				task.wait()
			end
			return true
		end
	end
	return false
end

function farmPuffshrooms()
	local firstPuff = getBestPuffshroom()
	if not firstPuff or not firstPuff.Model then return end
	local puffsOnField = {}

	local puffSelected = firstPuff.Model
	local fieldSelected = findField(firstPuff.Model.PrimaryPart.Position)

	while puffSelected and puffSelected.Parent do
		task.wait()
		local done, msg = farmPuffshroom(puffSelected)
		if msg == "Bag is full" then return false end
		task.wait()
		if vitaly.autoPuffshroomSettings.farmRemaining then
			puffsOnField = getPuffsOnField(fieldSelected)
			if #puffsOnField > 0 then
				for i,v in pairs(puffsOnField) do
					if v.Parent then
						puffSelected = v
						break
					end
				end
			end
			task.wait()
		end
	end
end

function avoidWarningDisks()
	local playerPos = api.humanoidrootpart().Position
	local warningDisks = getWarningDisks()

	local ray = Ray.new(playerPos + Vector3.new(0, 100, 0), Vector3.new(1, -735, 1))
	local touchedWarningDisk = Workspace:FindPartOnRayWithWhitelist(ray, warningDisks)

	if touchedWarningDisk then
		local diskRadius = touchedWarningDisk.Size.X / 2
		local dirToPlayer = (playerPos - touchedWarningDisk.Position).Unit

		-- Calculate the safe position to move to
		local diskCenter = touchedWarningDisk.Position
		local playerToCenter = (playerPos - diskCenter).Magnitude
		local playerToDisk = playerToCenter - diskRadius
		local safePos = diskCenter + dirToPlayer * (diskRadius + 4 + playerToDisk + 5)
		if (safePos - api.humanoidrootpart().Position).magnitude < 0.5 then safePos = api.humanoidrootpart().Position + Vector3.new(1,0,0) end
		api.humanoid():MoveTo(safePos + Vector3.new(1,0,1))
		task.wait()
		return true
	end
	task.wait()
	return false
end

function shouldIConvert(converting, check1)
	check1 = check1 or true
	local timeSinceLastFullBag = tick() - temptable.lastFullBag -- Calculate the time elapsed since the last conversion

	if timeSinceLastFullBag < vitaly.convertSettings.secondsBeforeConvert then -- Check if the user wants to wait before converting, and if enough time has elapsed
		return false
	elseif converting and getBagPercentage() > 0 or getBagPercentage() >= vitaly.convertSettings.convertat then -- Check if the bag is full or if the user wants to convert manually
		if vitaly.convertSettings.instantToggle and check1 then
			instaConvFunc()
			task.wait(1.5)
			return shouldIConvert()
		end
		return true
	else
		if temptable.puffsDetected and vitaly.autoPuffshroomSettings.farmPuffshrooms then return false end

		if vitaly.toggles.converthiveballoon and gethiveballoon() then
			if vitaly.convertSettings.convertballoonat == 0 and converting then
				return true
			elseif vitaly.convertSettings.convertballoonat ~= 0 and (tonumber(getBuffTime("Balloon Blessing"))/60) <= vitaly.convertSettings.convertballoonat then
				return true
			else
				return false
			end
		else
			return false
		end
	end
end

function getBagPercentage()
	local pollencount = player.CoreStats:FindFirstChild("Pollen") and player.CoreStats.Pollen.Value or 0
	local maxpollen = player.CoreStats:FindFirstChild("Capacity") and player.CoreStats.Capacity.Value or 0
	-- print(pollencount, maxpollen)

	local percentage = (pollencount / maxpollen * 100) or 0

	if temptable.lastFullBag == 0 and percentage >= vitaly.convertSettings.convertat then
		temptable.lastFullBag = tick()
	elseif not (percentage >= vitaly.convertSettings.convertat) then
		temptable.lastFullBag = 0
	end

	return percentage
end

function canToyBeUsed(toyName)
	local toy = Workspace.Toys[toyName]
	if toy then
		local _, buttonColor = secureCall(ActivatablesToys.ButtonText, Activatables, nil, toy)
		if not buttonColor then
			return true
		elseif buttonColor == "Red" then
			return false    
		end
	end
end

function useToy(toyName, collectTokens)
	if not canToyBeUsed(toyName) then return end
	local used = false
	local patformPosition = Workspace.Toys[toyName].Platform.Position + Vector3.new(0,3,0)
	task.wait()
	while 
		not temptable.convertingHoney
		and canToyBeUsed(toyName) 
	do
		if api.magnitude(patformPosition) > 20 then
			moveTo(patformPosition)
			task.wait(0.25)
		end
		if api.magnitude(patformPosition) < 20 then
			secureCall(ActivatablesToys.ButtonEffect, Activatables, player, workspace.Toys[toyName])
			-- setIdentity(2)
			-- ActivatablesToys.ButtonEffect(player, workspace.Toys[toyName])
			-- setIdentity(7)
		end
		task.wait(2)
	end
	if collectTokens then 
		task.wait(1.5)
		local tokensNear = {}
		for _, token in pairs(temptable.tokenpath:GetChildren()) do
			if api.magnitude(token.Position, patformPos) < 25
				and token.CFrame.YVector.Y == 1
				and getTokenId(token) ~= 65867881 then
				table.insert(tokensNear, token)
			end
		end
		while #tokensNear > 0 do
			for _, token in pairs(tokensNear) do
				if api.magnitude(patformPosition) > 25 then
					moveTo(patformPosition)
				end
				if not token.Parent then table.remove(tokensNear, _) continue end
				collectToken(token)
			end
			task.wait()
		end 
	end
end

local InstantConverterNames = {"Instant Converter","Instant Converter B","Instant Converter C"}

local instantConvList = {"All", "Ticket/Instant Converter", "Micro-Converter"}

function instaConvFunc()
	local isConverted = false
	for i,v in pairs(vitaly.convertSettings.selectedInstant) do
		--sakata jump
		if v:find("Ticket") and getClientStatCache("Eggs", "Ticket") ~= 0 and (tick() - temptable.IConverterUsedAt) > 15  then
			for _,c in pairs(InstantConverterNames) do
				if canToyBeUsed(c) then
					useToy(c)
					task.wait(1)
					temptable.IConverterUsedAt = tick()
					if not canToyBeUsed(c) then isConverted = true break end
				end
			end
			--  elseif v:find("Coconuts") and getClientStatCache("Eggs", "Coconut") ~= 0 then
			--     Events.ClientCall("PlayerActivesCommand", {Name = "Coconut"})
			--     isConverted = true 
			--     break
		elseif v:find("Micro") and getClientStatCache("Eggs", "Micro-Converter") ~= 0 and (tick() - temptable.MConverterUsedAt) > 15 then
			Events.ClientCall("PlayerActivesCommand", {Name = "Micro-Converter"})
			temptable.MConverterUsedAt = tick()
			isConverted = true 
			break
		elseif v == "All" then
			for _,c in pairs(InstantConverterNames) do
				if getClientStatCache("Eggs", "Ticket") == 0 then continue end
				if canToyBeUsed(c) then
					useToy(c)
					task.wait(1)
					if not canToyBeUsed(c) then isConverted = true break end
				end
			end
			-- if getClientStatCache("Eggs", "Coconut") ~= 0 then
			--     Events.ClientCall("PlayerActivesCommand", {Name = "Coconut"})
			--     isConverted = true 
			--     break
			-- end
			if getClientStatCache("Eggs", "Micro-Converter") ~= 0 then
				Events.ClientCall("PlayerActivesCommand", {Name = "Micro-Converter"})
				isConverted = true 
				break
			end
		end
	end
	return isConverted
end

function convertHoney(defaultMask)
	temptable.convertingHoney = true
	local hivePos = (player.SpawnPos.Value * CFrame.fromEulerAnglesXYZ(0, 110, 0) + Vector3.new(0, 0, 9)).p
	moveTo(hivePos)
	if vitaly.toggles.AutoHoneyM == true then
		local args = {
			[1] = "Equip",
			[2] = {
				["Category"] = "Accessory",
				["Type"] = "Honey Mask"
			}
		}
		
		game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("ItemPackageEvent"):InvokeServer(unpack(args))
	end
	repeat wait(.01)
		if game.Players.LocalPlayer.PlayerGui.ScreenGui.ActivateButton.TextBox.Text ~= "Stop Making Honey" then
			game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
		end
		if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position-hivePos).magnitude > 4 then
			moveTo(hivePos)
		end
	until game.Players.LocalPlayer.PlayerGui.ScreenGui.ActivateButton.TextBox.Text ~= "Stop Making Honey"
	wait(3.5)
	temptable.convertingHoney = false
	if vitaly.toggles.AutoHoneyM == true then
		local args = {
			[1] = "Equip",
			[2] = {
				["Category"] = "Accessory",
				["Type"] = vitaly.vars.defaultmask
			}
		}
		
		game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("ItemPackageEvent"):InvokeServer(unpack(args))
	end
	temptable.lastConvertAtHive = tick()
end

function useMemoryMatch(memoryMatch, isQuest)
	if canToyBeUsed(memoryMatch) and not temptable.convertingHoney then disableall() else return "first" end
	local patformPos = Workspace.Toys[memoryMatch].Platform.Position
	local used = false
	while canToyBeUsed(memoryMatch) 
		and (not isQuest and vitaly.toggles.automemorymatch or isQuest and vitaly.autoQuestSettings.useMemoryMatch)
		and not temptable.activeMemoryMatch
	do
		moveTo(patformPos)
		task.wait(0.5)
		if (patformPos - api.humanoidrootpart().Position).Magnitude < 15 then
			secureCall(ActivatablesToys.ButtonEffect, Activatables, player, workspace.Toys[memoryMatch])
			used = true
		end
		task.wait(1)
	end
	if not used then return end
	warn("MM step 1")
	repeat task.wait() until temptable.activeMemoryMatch
	warn("MM step 2")
	repeat task.wait() until not temptable.activeMemoryMatch
	warn("MM step 3: Done.")
	enableall()
end
function getAllNectar(bool)
	if bool then
		local tablereturn = {}
		for i, v in pairs(nectarsDropdownTable) do
			table.insert(tablereturn, {name = v, time = getBuffTime(v, true)})
		end
		return tablereturn
	end
end

function useGlueDispenser()
	local gumdropsCount = getClientStatCache("Eggs", "Gumdrops")
	local used = false
	while canToyBeUsed("Glue Dispenser") and gumdropsCount and gumdropsCount > 0 do
		moveTo(Vector3.new(4, 87, 487))
		task.wait(0.5)
		if api.magnitude(Vector3.new(4, 87, 487)) > 0.75 then continue end
		gumdropsCount = getClientStatCache("Eggs", "Gumdrops")
		task.wait()
		PlayerActivesCommand:FireServer({["Name"] = "Gumdrops"})
		task.wait(0.5)
		while getClientStatCache("Eggs", "Gumdrops") == gumdropsCount do task.wait() end
		if api.magnitude(Vector3.new(272, 25260, -744)) > 30 then continue end
		api.humanoid():MoveTo(Vector3.new(270.8, 25257, -722.5))
		api.humanoid().MoveToFinished:Wait(2)
		task.wait(0.5)
		useToy("Glue Dispenser")
		used = true
	end
	if used then 
		player.Character:BreakJoints()
		player.CharacterAdded:Wait(10)
		task.wait(5)
	end
end

function getToys()
	for toysTableName, toysTable in pairs(AllToysTable) do
		for configToyName, toyName in pairs(toysTable) do 
			if toysTableName == "toysTable" and vitaly.toggles[configToyName]
				or toysTableName == "boostersTable" and vitaly.autoboostersettings[configToyName] and vitaly.toggles.autoboosters
				or toysTableName == "dispensersTable" and vitaly.autodispensersettings[configToyName] and vitaly.toggles.autodispensers
			then
				if toyName ~= "Glue Dispenser" then
					useToy(toyName)
				else
					useGlueDispenser()
				end
			elseif toysTableName == "beesmasToysTable" and vitaly.toggles[configToyName] and scriptType == LPH_STRENC("Paid") then
				useToy(toyName, true)
			elseif toysTableName == "memoryMatchTable" and vitaly.toggles.automemorymatch then
				useMemoryMatch(toyName)
			end
		end
	end
end

function lockMovement(bool)
	if bool then
		setIdentity(origThreadIdentity)
		player.DevComputerMovementMode = Enum.DevComputerMovementMode.Scriptable
	else
		setIdentity(origThreadIdentity)
		player.DevComputerMovementMode = Enum.DevComputerMovementMode.UserChoice
	end
end

function getCrosshairs()
	local crosshairs = {all = {}, purple = {}}
	for i,v in pairs(Workspace.Particles:GetChildren()) do
		if v.Name == "Crosshair" and findField(v.Position) == findField(api.humanoidrootpart().Position) then
			if not v:FindFirstChild("Collected") then
				if v.BrickColor == BrickColor.new("Red flip/flop") then
					table.insert(crosshairs.all, v)
				elseif v.BrickColor == BrickColor.new("Alder") then
					table.insert(crosshairs.all, v)
					table.insert(crosshairs.purple, v)
				end
			end
		end
	end
	return {all = crosshairs.all, purple = crosshairs.purple}
end

function updateCrosshairs(shouldLock,exception) 
	for i,v in pairs(getCrosshairs().all) do
		if shouldLock and v ~= exception and v.BrickColor == BrickColor.new("Red flip/flop") then
			v.CanCollide = true
		elseif not shouldLock then
			v.CanCollide = false
		end
	end
end

function farmCrosshair(crosshair, save_height)
	local Path = PathfindingService:CreatePath({
		AgentRadius = 5,
		WaypointSpacing = 6,
		Costs = {
			Crosshair = math.huge
		}
	})
	updateCrosshairs(true, crosshair)
	Path:ComputeAsync(api.humanoidrootpart().Position, crosshair.Position)
	if Path then
		local points = Path:GetWaypoints()
		lockMovement(true)
		for _,v in pairs(points) do
			if (crosshair.Position - api.humanoidrootpart().Position).magnitude < 4 then break end
			if not crosshair.Parent or save_height ~= crosshair.Position.y then return lockMovement(false) end
			local moveComplete = false
			local startTime = tick()
			api.humanoid():MoveTo(v.Position)
			local signal
			signal = api.humanoid().MoveToFinished:Connect(function() moveComplete = true signal:Disconnect() end)
			repeat task.wait() until moveComplete or (tick() - startTime) > 0.85 or not crosshair.Parent or save_height ~= crosshair.Position.y or api.magnitude(crosshair.Position) < 5
		end
		lockMovement(false)
	end
	markAsCollected(crosshair)
	repeat task.wait() api.humanoid():MoveTo(crosshair.Position) until not crosshair.Parent or save_height ~= crosshair.Position.y
	updateCrosshairs(false)
end

function smartFarmCrosshairs()
	local buffStack = tonumber(getBuffStack("Precision"))
	local buffTime = tonumber(getBuffTime("Precision"))
	local isFarmed = false

	if (buffStack < 10 or buffTime <= 30) then
		for _,crosshair in pairs(getCrosshairs().all) do
			if not crosshair.Parent then continue end
			local MoveToFinished, started = false, tick()
			local save_height = crosshair.Position.y
			if crosshair.BrickColor == BrickColor.new("Forest green") or crosshair.BrickColor == BrickColor.new("Royal purple") then continue end
			lockMovement(true)
			api.humanoid():MoveTo(crosshair.Position)
			local signal
			signal = api.humanoid().MoveToFinished:Connect(function() MoveToFinished = true signal:Disconnect() end)
			repeat task.wait() until MoveToFinished or save_height ~= crosshair.Position.y or (tick() - started) > 5 or api.magnitude(crosshair.Position) < 4 or not crosshair.Parent
			lockMovement(false)
			markAsCollected(crosshair)
			isFarmed = true
		end
	elseif (buffStack == 10 and buffTime > 30) then
		for _,crosshair in pairs(getCrosshairs().purple) do
			if not crosshair.Parent then continue end
			local save_height = crosshair.Position.y
			if vitaly.autoFarmSettings.smartPreciseMethod == "Walk" then
				isFarmed = true
				farmCrosshair(crosshair, save_height)
			else
				repeat task.wait() 
					if api.magnitude(crosshair.Position) > 5 then
						startTween(crosshair.Position - Vector3.new(0,1.8,0), 350)
					end
				until not crosshair.Parent or save_height ~= crosshair.Position.y or (#getCrosshairs().purple > 1)
				markAsCollected(crosshair)
				isFarmed = true
			end
			break
		end
	end
	return isFarmed
end

function getSpawnerTime(spawner, extraSeconds)
	local spawnerInfo = monstersTable[spawner.Name]
	if not spawnerInfo then return math.huge end

	local lastKillTime = getClientStatCache("MonsterTimes", spawner.Name) or 0
	local spawnerCooldown = ClientMonsterTools.GetSpawnerCooldown(spawner.Name)
	local currentTime = ServerTime()

	if not spawnerCooldown then return math.huge end


	local timeLeft = (lastKillTime + spawnerCooldown - currentTime) + (tonumber(extraSeconds) or 0)
	if timeLeft < 0 then
		timeLeft = 0
	end

	return timeLeft
end

function getSpawnerCooldownText(spawnerName)
	local spawner = ClientMonsterTools.GetSpawner(spawnerName)
	if not spawner then return "???", -1 end

	local timeLeft = math.round(getSpawnerTime(spawner))
	if timeLeft == math.huge then 
		return "???", -1 
	end

	local cooldownText
	if timeLeft == 0 then
		cooldownText = "âœ…"
	else
		cooldownText = truncatetime(timeLeft)
	end

	return cooldownText, timeLeft
end

function getAliveMonsters(monsterName)
	local aliveMonsters = {}
	for i,v in pairs(Workspace.Monsters:GetChildren()) do
		if v.Name:find(monsterName) and v.Target.Value == player.Character then
			table.insert(aliveMonsters, v)
		end
	end
	return aliveMonsters
end

function getSpawnedMonsters(mob)
	local respawnedMonsters = {}
	for spawnerName,spawnerConfig in pairs(monstersTable) do
		if spawnerConfig.MonsterType == mob then
			local timeLeft = getSpawnerTime(spawnerConfig.Spawner, 30)
			if timeLeft == 0 then
				table.insert(respawnedMonsters, spawnerConfig)
			end
		end
	end
	return respawnedMonsters
end

function isMonsterKilled(mobSpawner)
	local spawner = ClientMonsterTools.GetSpawner(mobSpawner)
	if not mobSpawner or not spawner then --[[warn(1)]] return true end

	local timeLeft = getSpawnerTime(spawner)
	if timeLeft > 0 then
		return true
	else 
		return false
	end
end

function killMonster(territory, spawner)
	local startTimeStamp = tick()
	temptable.doingMonster = true
	while not isMonsterKilled(spawner.Name) do
		if (tick() - startTimeStamp) > 60 then break end
		if api.magnitude(territory.Position) > 60 then
			moveTo(territory.Position)
			task.wait(0.25)
		end
		if spawner.Name:find("ForestMantis") then 
			if api.magnitude(territory.Position + Vector3.new(0,0,15)) < 6 then
				api.humanoid():MoveTo(territory.Position - Vector3.new(0,0,15))
			else
				api.humanoid():MoveTo(territory.Position + Vector3.new(0,0,15))
			end
		end
		task.wait(0.5)
		jump()
		task.wait(1)
	end
	temptable.doingMonster = false
	return isMonsterKilled(spawner)
end

function killVicious()
	if vitaly.combatSettings.killVicious and temptable.detected.vicious then
		local viciousModel
		for i, v in pairs(Workspace.Particles:GetChildren()) do
			if v.Name:find("Vicious") then
				for i2, v2 in pairs(Workspace.Monsters:GetChildren()) do 
					if v2.Name:find("Vicious") and v2:FindFirstChild("HumanoidRootPart") then
							viciousModel = v2
							moveTo(v.Position)
							task.wait(0.5)
					end
				end
			end
		end
		if viciousModel then
			local viciousOnField = findField(viciousModel.HumanoidRootPart.Position)
			-- warn(viciousOnField)
			local level = tonumber(string.gmatch(viciousModel.Name, "%d+")())
			while viciousModel and viciousOnField and viciousModel.Parent and vitaly.combatSettings.killVicious and temptable.detected.vicious do
				if not viciousModel.Parent then viciousModel = nil break end
				if viciousOnField then
					-- warn(findField(api.humanoidrootpart().Position))
					if findField(api.humanoidrootpart().Position) ~= viciousOnField then
						moveTo(viciousOnField.Position)
					end
					if api.magnitude(viciousModel.HumanoidRootPart.Position) > 50 then
						api.humanoid():MoveTo(viciousModel.HumanoidRootPart.Position)
						task.wait(0.75)
					end
					collectNearestTokens(nil, 70)
					avoidWarningDisks()
				end
				task.wait()
			end
		end
	end
end

function getQuestInfo(questName)
	setIdentity(2)
	local toReturn = Quests.Get(nil, questName)
	setIdentity(origThreadIdentity)
	return toReturn
end

function getQuestProgress(questName)
	setIdentity(2)
	local toReturn = Quests.Progress(nil, questName, getClientStatCache())
	setIdentity(origThreadIdentity)
	return toReturn
end

function getQuestSetting(npc, Type)
	return(npc == "Black Bear" and (Type == "prio" and vitaly.autoQuestSettings.BlackBearPriority or Type == "toggle" and vitaly.autoQuestSettings.BlackBearQuests))
		or (npc == "Brown Bear" and (Type == "prio" and vitaly.autoQuestSettings.BrownBearPriority or Type == "toggle" and vitaly.autoQuestSettings.BrownBearQuests))
		or (npc == "Panda Bear" and (Type == "prio" and vitaly.autoQuestSettings.PandaBearPriority or Type == "toggle" and vitaly.autoQuestSettings.PandaBearQuests))
		or (npc == "Science Bear" and (Type == "prio" and vitaly.autoQuestSettings.ScienceBearPriority or Type == "toggle" and vitaly.autoQuestSettings.ScienceBearQuests))
		or (npc == "Polar Bear" and (Type == "prio" and vitaly.autoQuestSettings.PolarBearPriority or Type == "toggle" and vitaly.autoQuestSettings.PolarBearQuests))
		or (npc == "Spirit Bear" and (Type == "prio" and vitaly.autoQuestSettings.SpiritBearPriority or Type == "toggle" and vitaly.autoQuestSettings.SpiritsBearQuests))
		or (npc == "Bucko Bee" and (Type == "prio" and vitaly.autoQuestSettings.BuckoBeePriority or Type == "toggle" and vitaly.autoQuestSettings.BuckoBeeQuests))
		or (npc == "Riley Bee" and (Type == "prio" and vitaly.autoQuestSettings.RileyBeePriority or Type == "toggle" and vitaly.autoQuestSettings.RileyBeeQuests))
		or (npc == "Honey Bee" and (Type == "prio" and vitaly.autoQuestSettings.HoneyBeePriority or Type == "toggle" and vitaly.autoQuestSettings.HoneyBeeQuests))
		or (npc == "Onett" and (Type == "prio" and vitaly.autoQuestSettings.OnettQuests or Type == "toggle" and vitaly.autoQuestSettings.OnettQuests))
		or (npc == "Bee Bear 5" and (Type == "prio" and vitaly.autoQuestSettings.BeeBearPriority or Type == "toggle" and vitaly.autoQuestSettings.BeeBearQuests))
		or (Type == "prio" and 100 or Type == "toggle" and false)
end

function prioritizeQuests(quests)
	local prioritizedQuests = {}
	local tempQuestsTable = {}
	for i,questData in pairs(quests) do
		local prio = getQuestSetting(questData.npc, "prio") or 101
		table.insert(tempQuestsTable, {prio, i, questData.Name})
	end
	table.sort(tempQuestsTable, function(a, b)
		if a[1] == b[1] then
			return a[2] < b[2]
		else
			return a[1] < b[1]
		end
	end)
	for i,v in pairs(tempQuestsTable) do
		table.insert(prioritizedQuests, v[3])
	end
	return prioritizedQuests
end

function getActiveQuests(NPC)
	local quests = {}
	for _, v in pairs(getClientStatCache("Quests", "Active")) do
		local quest = getQuestInfo(v.Name)

		if quest and not quest.Hidden then
			local npc = quest.NPC
			if (not NPC and getQuestSetting(npc, "toggle")) or (NPC and npc == NPC) then
				table.insert(quests, {Name = v.Name, npc = npc})
			end
		end
	end

	local questNames = prioritizeQuests(quests)

	return questNames
end

function collectNearestTokens(nearqui, magnitude)
	if not nearqui or typeof(nearqui) ~= "Vector3" then
		if (typeof(nearqui) == "Instance" and not nearqui.Position) then
			nearqui = nearqui.Position
		else
			nearqui = api.humanoidrootpart().Position
		end
	end

	for i,v in pairs(Workspace.Collectibles:GetChildren()) do
		if not v.Parent or not v.Position or table.find(temptable.susTokenPositions, v.Position) then continue end
		if api.magnitude(nearqui, v.Position) < (magnitude or 30)
			and api.magnitude(nearqui * Vector3.new(0,1,0), v.Position * Vector3.new(0,1,0)) < 10 then
			collectToken(v)
			task.wait()
		end
	end
end

function farmBubbles()
	local speedModified = false
	local bubblesToCollect = {}
	local bubbleRadius = vitaly.toggles
	for i,v in pairs(Workspace.Particles:GetChildren()) do
		if v.Name:find("Bubble") and findField(v.Position) == temptable.fieldSelected then
			if #bubblesToCollect == 0 then 
				if not vitaly.toggles.smartBlueAutofarm then
					table.insert(bubblesToCollect, v)
				else
					if temptable.fieldPosition and api.magnitude(temptable.fieldPosition, v.Position) < 30 then
						table.insert(bubblesToCollect, v)
					end
				end
			else
				-- print(#bubblesToCollect)
				-- Check for nearest bubbles
				if api.magnitude(v.Position, bubblesToCollect[#bubblesToCollect].Position) < 15 then
					table.insert(bubblesToCollect, v)
					-- print("bubble added,", #bubblesToCollect,"bubbles to collect")
				end
			end
		end
	end
	if #bubblesToCollect >= 3 then
		if temptable.speedMultiplier == 1 then speedModified = true temptable.speedMultiplier = 1.3 end
		for i,bubble in ipairs(bubblesToCollect) do
			repeat task.wait()
				api.humanoid():MoveTo(bubble.Position)
			until api.magnitude(api.humanoidrootpart().Position, bubble.Position) <= 14 or not vitaly.toggles.autofarm or not bubble.Parent
		end
	end
	if speedModified then temptable.speedMultiplier = 1 end
end

function farmShowerAndCoco()
	if #temptable.showersTable > 0 and vitaly.autoFarmSettings.farmShower then
		while #temptable.showersTable > 0 do
			local key, warningisk = next(temptable.showersTable)
			if warningisk and warningisk.Parent and warningisk.Transparency > 0.09 then
				startTween(warningisk.Position, 350)
				-- tween(0.05, warningisk.Position, true)
				repeat task.wait()
				until not warningisk.Parent or warningisk.Transparency <= 0.08
				temptable.showersTable[key] = nil
			else
				temptable.showersTable[key] = nil
			end
			task.wait()
		end
		collectNearestTokens()
	elseif #temptable.coconutsTable > 0 and vitaly.autoFarmSettings.farmCoconuts then
		while #temptable.showersTable <= 0 and #temptable.coconutsTable > 0 do
			local key, warningisk = next(temptable.coconutsTable)
			if warningisk and warningisk.Parent and warningisk.Transparency > 0.09 then
				startTween(warningisk.Position, 350)
				-- tween(150, warningisk.Position)
				repeat task.wait()
				until not warningisk.Parent or warningisk.Transparency <= 0.08
				temptable.coconutsTable[key] = nil
			else
				temptable.coconutsTable[key] = nil
			end
			task.wait()
		end
		collectNearestTokens()
	end
end

function farmSprout(sprout, field)
	if not sprout or not sprout.Parent or not vitaly.autoFarmSettings.farmSprouts then return end

	local farmed = false

	while sprout and sprout.Parent and vitaly.autoFarmSettings.farmSprouts and vitaly.toggles.autofarm do
		-- print(findField(api.humanoidrootpart().Position), field)
		if getBagPercentage() >= 99 then
			convertHoney()
		end
		if findField(api.humanoidrootpart().Position) ~= field then
			moveTo(field.Position)
			task.wait()
		end
		collectNearestTokens(field.Position, 60)
		farmed = true
		task.wait()
	end

	return vitaly.autoFarmSettings.farmSprouts and vitaly.toggles.autofarm and farmed 
end

function farmSprouts()
	if next(temptable.sproutsTable) then
		while next(temptable.sproutsTable) and vitaly.autoFarmSettings.farmSprouts and vitaly.toggles.autofarm do
			local key, sprout = next(temptable.sproutsTable)
			if sprout and sprout.Model.Parent then
				if farmSprout(sprout.Model, sprout.Field) then
					for i = 1, 30 do
						collectNearestTokens(sprout.Field.Position, 100)
						task.wait()
					end
				end
			else
				temptable.sproutsTable[key] = nil
			end
			task.wait()
		end
	end
end

function selectField(fieldName)
	if fieldName == nil then
		temptable.fieldSelected = nil
		temptable.fieldPosition = nil
		return "Unselected field"
	end
	if temptable.fieldSelected and temptable.fieldSelected.Name == fieldName then return "Field already selected" end
	temptable.fieldSelected = Workspace.FlowerZones[fieldName] or "Dandelion Field"
	temptable.fieldPosition = temptable.fieldSelected.Position
	-- print("Selected field "..fieldName)
end

-- whitelistedTasks = {
--     "Collect Pollen", 
--     "Collect Goo",
--     "Defeat Monsters",
--     "Use Items",
--     "Use Toy",
--     "Match Pairs",
--     "Complete Quests"
-- }

function getQuestTasks(NPC)
	NPC = NPC or false
	local quests = getActiveQuests(NPC)
	local defeatMonstersTasks = {} -- table to hold the "Defeat Monsters" tasks
	local tasksToDo = {}

	for _, quest in pairs(quests) do
		local questData = getQuestInfo(quest)
		local questName = questData.Name
		if not vitaly.autoQuestSettings.doRepeatables and questData.Repeatable then continue end

		for index, questTask in pairs(getQuestProgress(questName)) do
			local iscompleted = questTask[1]

			if iscompleted >= 1 then continue end

			local fullTask = questData.Tasks[index]
			fullTask.Progress = questTask

			local taskDescription = fullTask.Description
			if typeof(taskDescription) ~= "string" then 
				setIdentity(2)
				taskDescription = taskDescription(getClientStatCache()) 
				setIdentity(origThreadIdentity)
			end

			local add = false

			if fullTask.Type == "Collect Pollen" and vitaly.autoQuestSettings.farmPollen
				or fullTask.Type == "Collect Goo" and vitaly.autoQuestSettings.farmGoo
				or fullTask.Type == "Defeat Monsters" and vitaly.autoQuestSettings.killMobs
				or fullTask.Type == "Use Toy" and vitaly.autoQuestSettings.useToys
				or fullTask.Type == "Match Pairs" and macvitalyrov2.autoQuestSettings.useMemoryMatch
				or fullTask.Type == "Complete Quests" and vitaly.autoQuestSettings.doQuestQuests
				or fullTask.Type == "Use Items" and taskDescription:find("Feed") and vitaly.autoQuestSettings.feedBees
			then
				add = true
			end

			if not add then continue end

			if fullTask.Type == "Defeat Monsters" then
				table.insert(defeatMonstersTasks, fullTask)
			else
				table.insert(tasksToDo, fullTask)
			end
		end
	end

	if vitaly.autoQuestSettings.prioritizeMobKill then
		for _, task in ipairs(defeatMonstersTasks) do
			table.insert(tasksToDo, 1, task)
		end
	else
		for _, task in ipairs(defeatMonstersTasks) do
			table.insert(tasksToDo, task)
		end
	end

	return tasksToDo
end

function getQuestTaskField(questTask)
	if questTask.Type == "Collect Pollen" or questTask.Type == "Collect Goo" then
		if questTask.Zone then
			return questTask.Zone
		elseif questTask.Color then
			return vitaly.autoQuestSettings["best"..questTask.Color.."Field"]
		end
	end
end

function claimQuests()
	for i, v in next, Workspace.NPCs:GetChildren() do
		if getQuestSetting(v.Name, "toggle") or 
			(vitaly.autoQuestSettings.acceptAllQuests and v.Name ~= "Honey Bee" and v.Name ~= "Gummy Bear" and v.Name ~= "Bubble Bee Man 2" and v.Name ~= "Ant Challenge Info" and v.Name ~= "Wind Shrine")
			and vitaly.autoQuestSettings.doQuests
		then
			local image = v.Platform.AlertPos.AlertGui.ImageLabel
			if image.ImageTransparency == 0 then
				if vitaly.toggles.tptonpc then
					api.humanoidrootpart().CFrame = CFrame.new(v.Platform.Position + Vector3.new(0,3,0))
				else
					moveTo(v.Platform.Position)
					task.wait(0.03)
				end


				local attempts = 0
				while image.ImageTransparency == 0 and api.magnitude(v.Platform.Position) <= 25 and attempts < 5 do
					if api.magnitude(v.Platform.Position) <= 25 and not ScreenGui.NPC.Visible then
						while not ScreenGui.NPC.Visible do
							if not (api.magnitude(v.Platform.Position) < 25) then break end
							-- secureCall(ActivatablesNPC.ButtonEffect, Activatables, player, v)
							setIdentity(2)
							ActivatablesNPC.ButtonEffect(player, Workspace.NPCs[v.Name])
							setIdentity(origThreadIdentity)
							task.wait(1.5)
						end
					end

					local tempTimestamp = tick()

					repeat task.wait() until ScreenGui.NPC.Visible or tick() - tempTimestamp > 10

					while ScreenGui.NPC.Visible do
						if ScreenGui.NPC.OptionFrame.Visible 
							and ScreenGui.NPC.OptionFrame.Option2.Visible 
							and ScreenGui.NPC.OptionFrame.Option2.Text:find("Talk to") then
							setIdentity(2)
							firesignal(ScreenGui.NPC.OptionFrame.Option2.MouseButton1Click)
							setIdentity(origThreadIdentity)
						else
							setIdentity(2)
							firesignal(ScreenGui.NPC.ButtonOverlay.MouseButton1Click)
							setIdentity(origThreadIdentity)
						end
						task.wait()
					end

					task.wait(2.5)
					attempts = attempts + 1
				end
				task.wait(0.5)
			end
		end
	end
end

function doQuests(NPC)
	NPC = NPC or false
	claimQuests()
	local questTasks = getQuestTasks(NPC)
	for taskIndex, questTask in pairs(questTasks) do
		-- print(questTask.Type, questTask.MonsterType, questTask.Amount)
		if questTask then
			local taskDescription = questTask.Description
			if typeof(taskDescription) ~= "string" then 
				setIdentity(2)
				-- print(1)
				taskDescription = taskDescription(getClientStatCache())
				-- print(2)
				setIdentity(origThreadIdentity)
			end

			if questTask.Type == "Collect Pollen" or questTask.Type == "Collect Goo" then
				local newField = getQuestTaskField(questTask)
				if newField and Workspace.FlowerZones:FindFirstChild(newField) then
					selectField(newField)
					break
				end
			elseif questTask.Type == "Defeat Monsters" then
				local monsterToKill = questTask.MonsterType
				local numberOfMonsters = questTask.Amount
				local monsterSpawners = getSpawnedMonsters(monsterToKill)
				local remainingAmount = numberOfMonsters - questTask.Progress[2]
				-- print("Alive",monsterToKill,":",#monsterSpawners)
				if #monsterSpawners > 0 then
					local monstersKilled = 0
					for i,v in pairs(monsterSpawners) do
						if remainingAmount <= 0 then print("brk!") break end
						if not isMonsterKilled(v.Spawner.Name) then
							local isKilled = killMonster(v.Territory, v.Spawner)
							if isKilled then
								monstersKilled += 1
								task.wait(1)
								for i=1,5 do
									collectNearestTokens(nil, 20)
								end
								remainingAmount = remainingAmount - 1
							end
						end
					end
				end
			elseif questTask.Type == "Use Items" then
				if false and not string.find(taskDescription, "Feed") and not questTask.Item:find("Jelly") then
					--UseItem
					if not temptable.questUseItemCooldown then
						game:GetService("ReplicatedStorage").Events.PlayerActivesCommand:FireServer({["Name"]=questTask.Item})
						task.spawn(function()
							temptable.questUseItemCooldown = true
							task.wait(100)
							temptable.questUseItemCooldown = false                        
						end)
					end
				elseif string.find(taskDescription, "Feed") then
					--Feed
					if not temptable.questFeedCooldown then
						Events.ClientCall("ConstructHiveCellFromEgg", math.random(1,5), 1, questTask.Item, questTask.Amount, false) 
						temptable.questFeedCooldown = true
						task.wait(5)
						temptable.questFeedCooldown = false  
					end
				end
			elseif questTask.Type == "Use Toy" then
				if canToyBeUsed(questTask.Toy) and not temptable.questUseToyCooldown then
					if not questTask.Toy:find("Glue") then
						useToy(questTask.Toy)
					else
						useGlueDispenser()
					end
					temptable.questUseToyCooldown = true
					task.wait(15)
					temptable.questUseToyCooldown = false 
					continue
				end
			elseif questTask.Type == "Match Pairs" then
				for i,v in pairs(AllToysTable["memoryMatchTable"]) do
					useMemoryMatch(v, true)
				end
			elseif questTask.Type == "Complete Quests" then
				doQuests(questTask.Pool or "Polar Bear")
			end
		end
	end
end

function handleMonsterKill(monsterName)
	for _,monster in pairs(getSpawnedMonsters(monsterName)) do
		if monster.Spawner and monster.Territory then
			killMonster(monster.Territory, monster.Spawner)
			task.wait(1)
			for i=1,3 do
				collectNearestTokens(nil, 20)
			end
		end
	end
end

function tryKillMonsters()
	if vitaly.combatSettings.killSpidor then
		handleMonsterKill("Spider")
	end
	if vitaly.combatSettings.killMantis then
		handleMonsterKill("Mantis")
	end
	if vitaly.combatSettings.killScorpion then
		handleMonsterKill("Scorpion")
	end
	if vitaly.combatSettings.killWerewolf then
		handleMonsterKill("Werewolf")
	end
end

function trainTunnelBear()
	if vitaly.combatSettings.trainTunnelBear then
		if #getSpawnedMonsters("Tunnel Bear") == 1 then
			tunnelPart.CanCollide = true
			local spawner = getSpawnedMonsters("Tunnel Bear")[1].Spawner
			while vitaly.combatSettings.trainTunnelBear and not isMonsterKilled(spawner.Name) do
				if api.magnitude(tunnelPart.Position) > 10 then
					moveTo(tunnelPart.Position)
					task.wait()
				end
				task.wait(0.1)
			end
			tunnelPart.CanCollide = false
			task.wait(1)
			if #getSpawnedMonsters("Tunnel Bear") == 0 then
				task.wait(0.5)
				for i=1,10 do
					if api.magnitude(tunnelPart.Position) > 250 then
						moveTo(tunnelPart.Position - Vector3.new(0,16,0))
					end
					collectNearestTokens(nil, 250)
				end
				task.wait(0.5)
			end
		end
	end
end

function trainCrab()
	if vitaly.combatSettings.trainCrab then
		if #getSpawnedMonsters("Coconut Crab") == 1 then
			local coconutField = Workspace.FlowerZones["Coconut Field"]
			local oldMask = getClientStatCache("EquippedAccessories", "Hat")
			if oldMask ~= "Demon Mask" and oldMask ~= "Gummy Mask" then
				requestAccessoryEquip("Demon Mask")
			end
			cocoPad.CanCollide = true
			local spawner = getSpawnedMonsters("Coconut Crab")[1].Spawner
			while vitaly.combatSettings.trainCrab and not isMonsterKilled(spawner.Name) do
				if api.magnitude(Vector3.new(-258, 109, 483)) > 50 then
					moveTo(Vector3.new(-441, 123, 498))
					task.wait(6)
					moveTo(Vector3.new(-258, 109, 483))
					task.wait()
				elseif api.magnitude(Vector3.new(-258, 109, 483)) > 15 then
					api.humanoid():MoveTo(Vector3.new(-258, 109, 483))
					api.humanoid().MoveToFinished:Wait(2)
				end
				if api.magnitude(Vector3.new(-258, 109, 483)) < 20 then
					collectNearestTokens(Vector3.new(-258, 109, 483), 20)
				end
				task.wait()
			end
			cocoPad.CanCollide = false
			if #getSpawnedMonsters("Coconut Crab") == 0 then
				task.wait(1)
				for i=1,25 do
					if findField(player.Character.HumanoidRootPart.Position) ~= coconutField then
						moveTo(coconutField.Position)
					end
					collectNearestTokens(coconutField.Position, 50)
				end
				task.wait(0.5)
			end
			if oldMask == "Diamond Mask" then
				requestAccessoryEquip("Diamond Mask")
			end
		end
	end
end

function trainStumpSnail()
	if not vitaly.combatSettings.trainStumpSnail then return false end
	if not (#getSpawnedMonsters("Stump Snail") >= 1) then return false end

	if vitaly.combatSettings.snailConvertHoney and getBagPercentage() >= 99 then return convertHoney(false) end

	if not isFieldSame(api.humanoidrootpart().Position, FlowerZones["Stump Field"].Position) then
		moveTo(FlowerZones["Stump Field"].Position)
		task.wait(2)
		placeSprinkler(nil, true, true)
	end

	local importantCallback = function(token) 
		if not (findField(token.Position) == FlowerZones["Stump Field"]) then return false end
		local Snail = getAliveMonsters("Stump Snail")[1]
		if not Snail then 
			return true
		else
			if Snail:FindFirstChild("Head") and api.magnitude(token.Position, (Snail.Head.Position - Vector3.new(0,10,0))) < 21 then return false end
			return true
		end
	end
	local isFarmed = false
	for i=1,5 do
		local farmed = farmToken(importantCallback)
		isFarmed = isFarmed or farmed
	end
	if not isFarmed and (tick() - temptable.lastWalkToNearest > 1.5) then
		local randomFlower = getRandomFlower(FlowerZones["Stump Field"])
		local Snail = getAliveMonsters("Stump Snail")[1]
		if randomFlower and 
			Snail and Snail:FindFirstChild("Head") and 
			api.magnitude(randomFlower.Position, (Snail.Head.Position - Vector3.new(0,10,0))) > 40
		then
			temptable.lastWalkToNearest = tick()
			api.humanoid():MoveTo(randomFlower.Position)
			task.wait(0.1)
		end
	end
	return true
end

function trainKingBeetle()
	if vitaly.combatSettings.trainKingBeetle then
		if #getSpawnedMonsters("King Beetle") == 1 then
			local spawner = getSpawnedMonsters("King Beetle")[1].Spawner

			temptable.customWalkSpeed.enabled = true
			temptable.customWalkSpeed.speed = 18

			while vitaly.combatSettings.trainKingBeetle and not isMonsterKilled(spawner.Name) do
				if api.magnitude(Vector3.new(179, 4, 194)) > 100 then
					moveTo(Vector3.new(172, 4, 144))
					task.wait(1)
					-- moveTo(Vector3.new(108, 4, 227))
					-- task.wait()
					api.humanoid():MoveTo(Vector3.new(109, 4, 253))
				end
				task.wait()
			end
			temptable.customWalkSpeed.speed = 50
			task.wait(1)
			if #getSpawnedMonsters("King Beetle") == 0 then
				for i=1,10 do
					collectNearestTokens(Vector3.new(179, 4, 194), 60)
				end
				task.wait(0.5)
			end
			temptable.customWalkSpeed.enabled = false
		end
	end
end

function isFieldOccupied(field)
	local planters = getMinePlanters()
	for _,planter in pairs(planters) do
		if planter.PotModel and planter.PotModel.Parent and planter.PotModel.PrimaryPart then
			if findField(planter.PotModel.PrimaryPart.Position).Name == field then
				return true
			end
		end
	end
	return false
end

function isPlanterPlanted(planterName)
	local planters = getMinePlanters()
	local planterData = getPlanterData(planterName)
	for _,planter in pairs(planters) do
		-- warn(planter.Type, planterData.systemName)
		if planter.Active and not planter.Collected and planter.Type == planterData.systemName then
			return true
		end
	end
	return false
end

function getBestPlanter(nectar, field, blacklisted)
	local bestPlanter = ""
	local bestZone = ""
	local bestNectarMultiplier = 0
	local bestZoneMultiplier = 0

	for planterName, planter in pairs(plantersTable) do
		if not table.find(vitaly.autoPlantersSettings.blacklistedPlanters, planter.systemName) 
			and not isPlanterPlanted(planterName) 
			and (planterName ~= "Plenty" and getClientStatCache("Eggs", planterName.."Planter") or getClientStatCache("Eggs", "The Planter Of Plenty")) then
			local fieldColor = Workspace.FlowerZones[field].ColorGroup.Value
			local nectarMultiplier = planter.nectarMultipliers[nectar] or 1
			local zoneMultiplier = planter.pollenMultipliers.Zones[fieldColor] or 1
			local colorMultiplier = planter.pollenMultipliers.Colors[fieldColor] or 1
			local overallMultiplier = nectarMultiplier * zoneMultiplier * colorMultiplier

			if overallMultiplier > bestNectarMultiplier * bestZoneMultiplier then
				bestPlanter = planterName
				bestZone = fieldColor
				bestNectarMultiplier = nectarMultiplier
				bestZoneMultiplier = zoneMultiplier * colorMultiplier
			end
		end
	end

	return bestPlanter, bestZone
end

function isNectarPending(nectartype)
	local planters = getMinePlanters()
	for i, v in pairs(planters) do
		local location = findField(v.PotModel.PrimaryPart.Position)
		if location then
			local conftype = NectarTypes.PickForField(location.Name)
			if conftype then
				if conftype.." Nectar" == nectartype then
					return true
				end
			end
		end
	end
	return false
end

function getBestNectarField(nectar)
	nectar = tostring(nectar)
	local nectar = nectar:gsub(" Nectar", "")
	if not nectarsTable[nectar] then return --[[warn(nectar, "not found")]] end
	local bestField = ""
	for index, nectarField in pairs(nectarsTable[nectar]) do
		if not isFieldOccupied(nectarField) and not (nectarField == "Ant Field") then
			bestField = nectarField
		end
	end
	return bestField
end

function calculateLeastNectar()
	local blacklistedNectars = vitaly.autoPlantersSettings.blacklistedNectars
	local leastNectar
	local leastNectarTime = math.huge
	for i,v in pairs(nectarsDropdownTable) do
		if table.find(blacklistedNectars, v) or isNectarPending(v) then continue end
		-- print(table.find(blacklistedNectars, v), isNectarPending(v))
		local currentNectarTime = getBuffTime(v)
		if currentNectarTime < leastNectarTime then
			leastNectar = v
			leastNectarTime = currentNectarTime
		end
	end
	-- warn(leastNectar)
	return leastNectar
end

function collectSpecificPlanter(planterPart, id)
	if planterPart and api.humanoid() and api.humanoid().Health > 0 and api.humanoidrootpart() then
		moveTo(planterPart.Position - Vector3.new(0,3,0))
		task.wait(1)
		if api.magnitude(api.humanoidrootpart().Position, planterPart.Position) < 20 then
			setIdentity(2)
			Events.ClientCall("PlanterModelCollect", id)
			-- LocalPlanters.PromptCollect(id)
			setIdentity(origThreadIdentity)
			task.wait(3)
			for i = 1, 5 do
				collectNearestTokens(nil, 50)
			end
			task.wait()
		end
	end
end

if _G.debugging then
	warn("Functions init done. Waiting 1 second")
	task.wait(1)
end

if _G.debugging then
	warn("Other Functions init.")
end

-- writefile("plantersData.json", jsonEncode(plantersTable))

function isPlanterExists(pNum)
	local exists = false
	local stuffs = getMinePlanters()
	if stuffs ~= {} then
		for i, v in pairs(stuffs) do
			if v["ActorID"] == pNum and v.Active and not v.Collected then
				exists = true
			end
		end
	end
	return exists
end

function plantPlanter(planterName, fieldName)
	if not planterName or not fieldName then return end
	local planterData = getPlanterData(planterName)
	-- print(planterName)
	local fieldSelected = Workspace.FlowerZones:FindFirstChild(fieldName)
	if not fieldSelected then return end
	local stepTable = {field = fieldName, planter = planterName}
	temptable.plantingPlanter = true
	while api.humanoidrootpart() and api.humanoid().Health > 0 and not checkIfPlanted(stepTable) and not isFieldOccupied(fieldName) do
		while not (api.magnitude(fieldSelected.Position) < 8) do
			moveTo(fieldSelected.Position)
			task.wait()
		end
		task.wait(0.5)
		PlayerActivesCommand:FireServer({["Name"] = planterData.displayName})
		task.wait(1)
	end
	plantingPlanter = false
end

function collectAllPlanters(collectPercentage)
	local plantersToCollect = {}
	for _,planter in pairs(getMinePlanters()) do
		if planter.GrowthPercent ~= nil then

			if planter.GrowthPercent >= ((collectPercentage or vitaly.autoPlantersSettings.planterHarvestAt) / 100) then
				table.insert(plantersToCollect, {
					["PM"] = planter["PotModel"].PrimaryPart,
					["AID"] = planter["ActorID"]
				})
			end
		end
	end
	if #plantersToCollect > 0 then
		for _,planter in pairs(plantersToCollect) do
			while isPlanterExists(planter.AID) do
				collectSpecificPlanter(planter.PM, planter.AID)
				task.wait(1)
			end
		end
	end
end

function getPlantersCacheFromFile()
	if not isfile(plantersCacheFilePath) then
		local defaultPlantersCache = {
			customPlanters1 = 1,
			customPlanters2 = 1,
			customPlanters3 = 1
		}
		writefile(plantersCacheFilePath, game.HttpService:JSONEncode(defaultPlantersCache))
	end
	return game.HttpService:JSONDecode(readfile(plantersCacheFilePath))
end

function getPlantersCache() 
	local Cache = plantersCache
	local isFromCache = true
	if not Cache then 
		isFromCache = false
		Cache = getPlantersCacheFromFile()
		plantersCache = Cache
	end
	-- print((isFromCache and "Loaded from Cache") or "Loaded from File")
	return Cache
end

function updatePlantersCache(cycle, newValue)
	local Cache = getPlantersCache()
	Cache["customPlanters"..cycle] = newValue
	plantersCache = Cache
	writefile(plantersCacheFilePath, game.HttpService:JSONEncode(Cache))
end

function checkIfPlanted(stepTable)
	local isPlanted,planter = false,nil
	for i,v in pairs(getMinePlanters()) do
		local planterName = getPlanterData(v.Type).displayName
		local planterField = findField(v.Pos)
		-- warn(stepTable.planter, planterName)

		if (stepTable.field == (planterField and planterField.Name))
			and(stepTable.planter == planterName) then
			-- print("FOUND PLANTER!")
			isPlanted = true
			planter = v
			break
		end
	end
	-- warn(isPlanted,planter)
	return isPlanted,planter
end

function isPlanterInConfig(planter)
	for i=1,3 do
		local cycleName = "customPlanters"..i
		local stepsTable = vitaly.customPlanterSettings[cycleName]
		for j=1,5 do
			local stepTable = stepsTable[j]
			if not (stepTable.planter and table.find(plantersDropdownTable, stepTable.planter))
				or not (stepTable.field and table.find(fieldsTable, stepTable.field))
			then
				continue
			else
				local isInConfig = (getPlanterData(stepTable.planter).displayName == planter.Name and stepTable.field == planter.Field)
				if isInConfig then return true end
			end
		end
	end
	return false
end

function autoPlanters()
	local shouldReturn = false
	if vitaly.autoPlantersSettings.doCustomPlanters then
		local planterCycles = vitaly.customPlanterSettings

		local steps = {
			customPlanters1 = 5, 
			customPlanters2 = 5, 
			customPlanters3 = 5
		}

		for i=1,3 do
			local cycleName = "customPlanters"..i
			local stepsTable = planterCycles[cycleName]
			for j=1,5 do
				local stepTable = stepsTable[j]
				if not (stepTable.planter and table.find(plantersDropdownTable, stepTable.planter))
					or not (stepTable.field and table.find(fieldsTable, stepTable.field))
				then
					steps[cycleName] -= 1
				else
					local isPlanted = checkIfPlanted(stepTable)
					-- warn("Is Planted: "..tostring(isPlanted))
					if isPlanted then updatePlantersCache(i,j) break end
				end
			end
		end

		local currentSteps = getPlantersCache()

		for i,planter in pairs(getMinePlanters()) do
			local planterName = getPlanterData(planter.Type).displayName
			local planterField = findField(planter.Pos) and findField(planter.Pos).Name

			if not isPlanterInConfig({Name = planterName, Field = planterField}) then
				-- print("NOT IN CONFIG")
				collectSpecificPlanter(planter.PotModel.PrimaryPart, planter.ActorID)
				shouldReturn = true
			end
		end

		for i=1,3 do
			local cycleName = "customPlanters"..i
			local stepsTable = planterCycles[cycleName]

			if steps[cycleName] == 0 then continue end
			local currentStep = currentSteps[cycleName]
			local config = stepsTable[currentStep]
			if currentStep > steps[cycleName] then 
				-- print("Step limit ",cycleName,currentStep,steps[cycleName])
				currentStep = 1 
				updatePlantersCache(i,1)
				currentSteps = getPlantersCache()
			end
			local isPlanted,Planter = checkIfPlanted(config)
			-- print(isPlanted, config)
			if not isPlanted and #getMinePlanters() < 3 then
				-- print("Not Planted")
				local planter = config.planter
				if planter:find("Plenty") then planter = "The Planter Of Plenty" elseif not table.find(plantersDropdownTable, planter) then continue end
				local planterData = getPlanterData(planter)
				local planterCount = getClientStatCache("Eggs", (planter:find("Plenty") and "Plenty" or planterData.systemName).."Planter") or 0
				if isFieldOccupied(config.field) or planterCount <= 0 or isPlanterPlanted(planterData.systemName) then
					warn("Skipped", cycleName, planter, config.field)
					updatePlantersCache(i,currentStep + 1)
					currentSteps = getPlantersCache()
					warn(currentSteps[cycleName])
				else
					plantPlanter(planterData.systemName, config.field)
					task.wait()
					shouldReturn = true
				end
			else
				if Planter.GrowthPercent >= (config.harvestAmount / 100) then
					if Planter.PotModel.Name == config.planter and findField(Planter.PotModel.PrimaryPart.Position).Name == config.field then
						collectSpecificPlanter(Planter.PotModel.PrimaryPart, Planter.ActorID)
						updatePlantersCache(i,currentStep + 1)
						currentSteps = getPlantersCache()
						shouldReturn = true
					end
				end
			end
		end
	end
	return shouldReturn
end

function farmDupedTokens()
	if #temptable.dupedTokensTable > 0 then
		local dupedToken = next(temptable.dupedTokensTable)
		if tonumber(dupedToken) then dupedToken = temptable.dupedTokensTable[dupedToken] end
		local succ,err = pcall(function()
			while dupedToken.Attachment.BillboardGuiFront.Smile.ImageColor3 ~= Color3.fromRGB(255, 0, 255) do
				local pos = dupedToken.Position - Vector3.new(0,10,0)

				player.Character.Humanoid:MoveTo(pos)

				task.wait(.05)
			end
			local index = table.find(temptable.dupedTokensTable, dupedToken)
			table.remove(temptable.dupedTokensTable, index)
		end)
		if not succ then warn(err) end
		if succ then return true end
	end
	return false
end

function mainAutofarmFunction()
	local function importantFarmTaskCallback(token)
		return findField(token.Position) == temptable.fieldSelected
	end

	while task.wait() do
		xpcall(function() 
			if temptable.stopEverything then return task.wait(.03) end

			if temptable.autoRBC.isActive then return task.wait(.03) end
			if canTaskBeSpawned("getToys") then
				getToys()
			end
			if vitaly.autoPlantersSettings.doCustomPlanters and canTaskBeSpawned("farmPlanters") then
				if autoPlanters() then return end
			end

			if vitaly.combatSettings.killVicious and temptable.detected.vicious and canTaskBeSpawned("killVicious") then
				killVicious()
			end

			tryKillMonsters()
			if canTaskBeSpawned("trainBosses") then
				if vitaly.combatSettings.trainKingBeetle then
					trainKingBeetle()
				end

				if vitaly.combatSettings.trainTunnelBear then
					trainTunnelBear()
				end

				if vitaly.combatSettings.trainCrab then
					trainCrab()
				end

				if vitaly.combatSettings.trainStumpSnail then
					if trainStumpSnail() then return end
				end
			end
			if not vitaly.toggles.convertHoney or not shouldIConvert() then

				if temptable.shouldEquipDefaultMask then
					temptable.shouldEquipDefaultMask = false
					requestAccessoryEquip(vitaly.vars.defaultmask)
					return
				end

				if temptable.puffsDetected and vitaly.autoPuffshroomSettings.farmPuffshrooms then
					farmPuffshrooms()
					return
				end

				if vitaly.autoFarmSettings.farmSprouts then
					farmSprouts()
				end

				selectField(vitaly.autoFarmSettings.field)

				if vitaly.autoQuestSettings.doQuests then
					doQuests()
				end

				if not isFieldSame(api.humanoidrootpart().Position, temptable.fieldPosition) then
					moveTo(temptable.fieldPosition + Vector3.new(0,3,0))
					if vitaly.autoFarmSettings.autoSprinkler then
						task.wait()
						placeSprinklers(temptable.fieldPosition)
					end
				end

				if vitaly.autoFarmSettings.smartPreciseCrosshair and #getCrosshairs().all > 0 then
					if smartFarmCrosshairs() then return end 
				end

				if vitaly.autoFarmSettings.farmDupedTokens then
					farmDupedTokens()
				end

				if vitaly.autoFarmSettings.farmShower or vitaly.autoFarmSettings.farmCoconuts then
					farmShowerAndCoco()
				end

				local isFarmed = false
				isFarmed = farmNearest(importantFarmTaskCallback)
				-- for i=1,3 do
				-- isFarmed = isFarmed or farmed
				-- end

				if vitaly.autoFarmSettings.farmUnderBalloons and math.random(68,70) == 69 then
					local farmed = gotoNearestBalloon()
					isFarmed = isFarmed or farmed
				end

				if not isFarmed and (tick() - temptable.lastWalkToNearest > 1.5) then
					local randomFlower = getRandomFlower(temptable.fieldSelected)
					if randomFlower then
						temptable.lastWalkToNearest = tick()
						api.humanoid():MoveTo(randomFlower.Position)
					end
				end
			elseif vitaly.toggles.convertHoney and shouldIConvert(false, false) then
				convertHoney(vitaly.toggles.converthiveballoon)
			end
		end, function(err) warn(("[Macro V3] (%s) | An error has occurred: %s"):format(temptable.version, err)) end)
	end
end

local autoDig

local autoRBC = {
	Listeners = {}, 
	Functions = {takeRBQuest, getActiveChallange}, 
	redBeesPriorityList = {["Rage"] = 6,["Bear"] = 1,["Shy"] = 15,["Rad"] = 16,["Shy"] = 15,["Rad"] = 16,["Shy"] = 15,["Rad"] = 16,["Brave"] = 9,["Baby"] = 13,["Windy"] = 5,["Spicy"] = 7,["Fire"] = 20,["Tabby"] = 2,["Cool"] = 36,["Demo"] = 32,["Lion"] = 41,["Honey"] = 30,["Demon"] = 37,["Riley"] = 26,["Vector"] = 8,["Hasty"] = 40,["Ninja"] = 42,["Bucko"] = 34,["Fuzzy"] = 23,["Music"] = 14,["Gummy"] = 17,["Puppy"] = 43,["Basic"] = 18,["Bumble"] = 27,["Bomber"] = 31,["Bubble"] = 33,["Cobalt"] = 35,["Frosty"] = 39,["Rascal"] = 44,["Tadpole"] = 21,["Precise"] = 3,["Digital"] = 4,["Looker"] = 10,["Photon"] = 12,["Shocked"] = 45,["Diamond"] = 28,["Buoyant"] = 29,["Vicious"] = 22,["Festive"] = 24,["Crimson"] = 11,["Stubborn"] = 46,["Carpenter"] = 19,["Commander"] = 25,["Exhausted"] = 38 },
	farmField = function(field)
		if not (findField(game.Players.LocalPlayer.Character.HumanoidRootPart.Position) == field)  then
			moveTo(field.Position + Vector3.new(0,3,0))
			task.wait(.5)
			PlayerActivesCommand:FireServer({["Name"] = "Sprinkler Builder"})
			task.wait()
		end

		if not macvitalyrov2.toggles.autodig then
			autoDig.Set(true)
		end

		local function importantFarmTaskCallback(token)
			return findField(token.Position) == field
		end

		local isFarmed = farmNearest(importantFarmTaskCallback)

		if not isFarmed and (tick() - temptable.lastWalkToNearest > 3) then
			local randomFlower = getRandomFlower(field)
			if randomFlower then
				temptable.lastWalkToNearest = tick()
				api.humanoid():MoveTo(randomFlower.Position)
			end
		end
	end,
	getTaskField = function(questTask)
		if questTask.Zone then
			return questTask.Zone
		elseif questTask.Color then
			return vitaly.autoQuestSettings["best"..questTask.Color.."Field"]
		else
			return vitaly.autoQuestSettings["bestRedField"]
		end
	end
}


autoRBC.Functions = {
	getActiveChallange = function() 
		return secureCall(RoboBearGui.GetActiveChallengeData, Activatables)
	end,

	selectQuest = function()
		Events.ClientCall("RoboBearQuestSelect", math.random(1,2))
	end,

	selectBee = function(beesTable)
		local playerFile = getClientStatCache()
		local bestBee = {priority = math.huge, index = 1, beeName = nil}
		for beeIndex=1, #beesTable do
			local obfuscatedBee = beesTable[beeIndex]
			local obfuscatedBeeX = obfuscatedBee[1]
			local obfuscatedBeeY = obfuscatedBee[2]

			local beeFile = secureCall(StatTools.GetBeeFile, Activatables, playerFile, obfuscatedBeeX, obfuscatedBeeY)
			if beeFile then
				local beePriority = autoRBC.redBeesPriorityList[beeFile.Type]
				if beePriority and beePriority < bestBee.priority then
					bestBee.priority = beePriority
					bestBee.index = beeIndex
					bestBee.beeName = beeFile.Type
				end
			end
		end
		Events.ClientCall("RoboBearBeeSelect", bestBee.index or 1)
	end,

	chooseUpgrades = function()
		Events.ClientCall("RoboBearRoundStart")
	end,

	onRoundStart = function()
		while task.wait() do
			local currentChallangeData = autoRBC.Functions.getActiveChallange()
			if not currentChallangeData then return end

			local playerFile = getClientStatCache()

			local ActiveQuest = currentChallangeData.ActiveQuest

			if not ActiveQuest or not ActiveQuest.Tasks then continue end

			local tasks = ActiveQuest.Tasks
			local progress = secureCall(Quests.GetProgression, Activatables, nil, tasks, playerFile)
			if progress then
				writefile("rbc/progress_1.json", game.HttpService:JSONEncode(progress))
				writefile("rbc/teasks_1.json", game.HttpService:JSONEncode(tasks))
				for i,v in ipairs(tasks) do
					if progress[i][1] < 1 then
						local taskType = tasks[i].Type
						if taskType == "Collect Pollen" or taskType == "Make Honey" or taskType == "Collect Goo" then
							local taskTable = {}
							if taskType == "Collect Pollen" then
								taskTable.Color = tasks[i].Color
								taskTable.Zone = tasks[i].Zone
							elseif taskType == "Make Honey" or taskType == "Collect Goo" then
								taskTable.Color = "Red"
							end
							local fieldName = autoRBC.getTaskField(taskTable)
							-- print(fieldName)
							if fieldName and game.Workspace.FlowerZones:FindFirstChild(fieldName) then
								pcall(function() 
									autoRBC.farmField(game.Workspace.FlowerZones:FindFirstChild(fieldName))
								end)
							end
						end
						break
					end
				end
			end
		end
	end,

	onRoundEnd = function()
		local playerInventory = getClientStatCache("Eggs")
		if playerInventory.Cogs then
			local function buyDrive(driveName)
				if player:DistanceFromCharacter(Vector3.new(-473, 60, 106)) > 25 then
					moveTo(Vector3.new(-473, 60, 106))
					task.wait(.25)
				end
				task.wait(.25)
				Events.ClientCall("ItemPackageEvent", "Purchase", {
					Type = "Robo Bear "..driveName, Amount = 1, Category = "Bundle"
				})
				task.wait(.1)
			end
			while playerInventory.Cogs >= 50 do
				if (playerInventory.WhiteDrive or 0) < 5 then
					buyDrive("White Drive")
				elseif (playerInventory.RedDrive or 0) < 5 then
					buyDrive("Red Drive")
				elseif (playerInventory.BlueDrive or 0) < 5 then
					buyDrive("Blue Drive")
				elseif (playerInventory.GlitchedDrive or 0) < 5 then
					buyDrive("Gitched Drive")
				else break end
			end
			task.wait()
		end
		autoRBC.Functions.takeRBQuest()
	end,

	onChallangeEnd = function() 
		for i,v in pairs(autoRBC["Listeners"]) do
			pcall(function() v:Disconnect() end)
		end

		Events.ClientCall("RoboBearClaimRewards")

		temptable.autoRBC.latestRBC = tick() + 5

		task.wait(2.5)

		temptable.autoRBC.isActive = false
	end,
	takeRBQuest = function()
		warn(2)
		local attempts = 0
		local activaChallange = autoRBC.Functions.getActiveChallange()
		while (not activaChallange or activaChallange.RoundState ~= "Running") and attempts < 5 do

			if api.magnitude(RoboBear.Platform.Position) <= 25 and not ScreenGui.NPC.Visible then
				while not ScreenGui.NPC.Visible and not (api.magnitude(RoboBear.Platform.Position) > 25) do
					secureCall(ActivatablesNPC.ButtonEffect, Activatables, player, RoboBear)
					task.wait(.5)
					continue
				end
			elseif api.magnitude(RoboBear.Platform.Position) > 25 then
				moveTo(RoboBear.Platform.Position + Vector3.new(0,3,0))
				task.wait(.5)
				continue
			end

			local tempTimestamp = tick()

			repeat task.wait() until ScreenGui.NPC.Visible or tick() - tempTimestamp > 10

			while ScreenGui.NPC.Visible do
				local optionText = ScreenGui.NPC.OptionFrame.Option1.Text
				if ScreenGui.NPC.OptionFrame.Visible 
					and ScreenGui.NPC.OptionFrame.Option1.Visible 
					and (optionText:find("Spend 1 Robo Pass") or optionText:find("Start Round")) then
					setIdentity(2)
					firesignal(ScreenGui.NPC.OptionFrame.Option1.MouseButton1Click)
					setIdentity(origThreadIdentity)
				else
					setIdentity(2)
					firesignal(ScreenGui.NPC.ButtonOverlay.MouseButton1Click)
					setIdentity(origThreadIdentity)
				end
				task.wait()
			end

			task.wait(2.5)
			attempts = attempts + 1
			activaChallange = autoRBC.Functions.getActiveChallange()
		end
		task.wait(0.5)
		return autoRBC.Functions.getActiveChallange()
	end
}



function mainAutoRBCFunction()
	warn(1)
	autoRBC["Listeners"][1] = EventsDir.RoboBearQuestSelect.OnClientEvent:Connect(autoRBC.Functions.selectQuest)
	autoRBC["Listeners"][2] = EventsDir.RoboBearBeeSelect.OnClientEvent:Connect(autoRBC.Functions.selectBee)
	autoRBC["Listeners"][3] = EventsDir.RoboBearUpgradeSelect.OnClientEvent:Connect(autoRBC.Functions.chooseUpgrades)
	autoRBC["Listeners"][4] = EventsDir.RoboBearRoundStart.OnClientEvent:Connect(autoRBC.Functions.onRoundStart)
	autoRBC["Listeners"][5] = EventsDir.RoboBearRoundEnd.OnClientEvent:Connect(autoRBC.Functions.onRoundEnd)
	autoRBC["Listeners"][6] = EventsDir.RoboBearChallengeEnd.OnClientEvent:Connect(autoRBC.Functions.onChallangeEnd)

	if autoRBC.Functions.takeRBQuest() then temptable.autoRBC.isActive = true end
end

function webhookFieldsList()
	local currentHoney = getClientStatCache("Totals","Honey")
	local timePassed = math.round(tick() - currentvitalyLoadedAt)
	-- print(currentHoney, temptable.honeyAtStart)
	local honeyGained = currentHoney - temptable.honeyAtStart
	-- print(currentHoney, timePassed, honeyGained)

	local honeyPerHour = math.floor(honeyGained / timePassed) * 3600
	local dailyHoney = getDailyHoney()

	local totalHoneyString = truncate(currentHoney)
	local honeyGainedString = truncate(honeyGained)
	local honeyPerHourString = truncate(honeyPerHour)
	local honeyPerDayString = truncate(dailyHoney)

	if not vitaly.webhookSettings.onlyTruncated then
		totalHoneyString = addcommas(currentHoney).." ("..totalHoneyString..")"
		honeyGainedString = addcommas(honeyGained).." ("..honeyGainedString..")"
		honeyPerHourString = addcommas(honeyPerHour).." ("..honeyPerHourString..")"
		honeyPerDayString = addcommas(dailyHoney).." ("..honeyPerDayString..")"
	end

	local uptimeString = truncatetime(timePassed)
	local fields = {}

	if vitaly.webhookSettings.showTotalHoney then
		table.insert(fields, {
			["name"] = "Total Honey:",
			["value"] = totalHoneyString,
			["inline"] =  false
		})
	end
	table.insert(fields, {
		["name"] = "Session Honey:       ",
		["value"] = honeyGainedString,
		["inline"] =  true
	})
	table.insert(fields, {
		["name"] = "Session Uptime:     ",
		["value"] = uptimeString,
		["inline"] =  true
	})
	if vitaly.webhookSettings.showHoneyPerHour then
		table.insert(fields, {
			["name"] = "Honey Per Hour:       ",
			["value"] = honeyPerHourString,
			["inline"] = false
		})
	end
	if vitaly.webhookSettings.showDailyHoney then
		table.insert(fields, {
			["name"] = "Honey Per Day:     ", -- 
			["value"] = honeyPerDayString,
			["inline"] = false
		})
	end
	if vitaly.webhookSettings.showNectars then
		local nectars = getAllNectar(true)
		local nectarsString = ""
		for index, nectar in pairs(nectars) do
			if nectar.time == 0 then continue end
			nectarsString = nectarsString..""..(nectarEmojis[nectar.name] or nectar.name..":").." "..nectar.time
			nectarsString = nectarsString.."\n"
		end
		if #nectarsString > 1 then
			table.insert(fields, {
				["name"] = "Nectars:",
				["value"] = nectarsString,
				["inline"] =  false
			})
		end
	end
	if vitaly.webhookSettings.showPlanters then
		local plantersString = ""
		pcall(function()
			local minePlanters = getMinePlanters()
			for i,v in pairs(minePlanters) do
				plantersString = plantersString..""..plantersEmojis[v.PotModel.Name].." "..math.floor(v.GrowthPercent*1000)/10 .. "%\n"
			end
		end)
		if plantersString ~= "" then
			table.insert(fields, {
				name = "Active Planters",
				value = plantersString,
				inline = false
			})
		end
	end
	if vitaly.webhookSettings.showItems then
		local itemsString = ""
		for index, item in pairs(vitaly.webhookSettings.itemsList) do
			local systemItem = getItemByName(item)
			if systemItem and systemItem.SystemName then 
				local systemName = systemItem.SystemName
				local count = getClientStatCache("Eggs", systemName) or 0
				itemsString = itemsString .. item .. ": **" .. tostring(count) .. "**\n"
			end
		end
		if itemsString ~= "" then
			table.insert(fields, {
				name = "Items",
				value = itemsString,
				inline = false
			})
		end
	end
	return fields
end

function generateWebhookBody(settings)
	local body = {
		["username"] = player.Name,
		["content"] = settings.content or "",
		["embeds"] = {{
			["title"] = "**"..settings.embedTitle.."**",
			["description"] = settings.embedDescription or "",
			["type"] = "rich",
			["color"] = tonumber(settings.color) or tonumber(vitaly.webhookSettings.webhookColor),
			["fields"] = settings.fields or {},
			["footer"] = {
				["text"] = os.date("%x").." â€¢ "..os.date("%I")..":"..os.date("%M")..--[[":"..os.date("%S")..]]" "..os.date("%p")
			}
		}}
	}
	return body
end

function sendWebhook(body)
	local headers = {
		["content-Type"] = "application/json"
	}
	xpcall(function()
		httpreq({
			Url = vitaly.webhookSettings.webhookUrl, 
			Body = HttpService:JSONEncode(body), 
			Method = "POST", 
			Headers = headers
		})
		task.wait()
		temptable.lastWebhookSent = math.round(tick())
	end, function(err) warn(("%s | Failed to send webhook: %s"):format(temptable.version, err)) end)
end

function questWebhook(npc,fields)
	local thumbnail = npcsIcons[npc]
	local data = generateWebhookBody({
		embedTitle = "Macro V3 | Quests",
		thumbnail = thumbnail,
		fields = fields
	})
	sendWebhook(data)
end

function sendHourlyWebhook(isTest)
	local ping = vitaly.webhookSettings.pingUser and "<@"..vitaly.webhookSettings.discordId..">" or ""
	local data = generateWebhookBody({
		content = (isTest and ping ~= "" and ping..", your webhook is working!") or (isTest and ping == "" and "Your webhook is working!") or ping,
		embedTitle = isTest and "Webhook Test" or "Honey Update",
		fields = webhookFieldsList()
	})
	sendWebhook(data)
end

function sendTestWebhook()
	local data = generateWebhookBody({
		embedTitle = "Test Webhook",
		embedDescription = "Hey from vitaly"
	})
	sendWebhook(data)
end

local newMemoryMatchStartGame = function() end
local MemoryMatchStartGame

if not getgenv().autoMMConfigured then
	getgenv().autoMMConfigured = true
	LPH_NO_VIRTUALIZE(function()
		MemoryMatchStartGame = MinigameGui.StartGame

		local function UpdateGameTable(a)
			local dupes = {}
			local exclude = a.Game.MatchedTiles

			for index, value in pairs(a.Game.RevealedTiles) do
				if exclude[index] == nil then 
					if dupes[value] == nil then
						dupes[value] = {Indexes = {index}}
					else
						table.insert(dupes[value]["Indexes"], index)
					end
				end
			end

			for i,v in pairs(dupes) do
				if #v.Indexes < 2 then dupes[i] = nil end
			end

			return dupes
		end

		newMemoryMatchStartGame = function(a)
			if not vitaly.toggles.automemorymatch and not vitaly.autoQuestSettings then return end
			repeat task.wait() until a and a.Game and a.Game.Grid and a.Game.Grid.InputActive
			temptable.activeMemoryMatch = a
			for Index = 1, a.Game.NumTiles do
				task.wait()
				warn("You have",a.Game.Chances,"chances left")
				if a.Game.Chances == 0 then break end
				setIdentity(2)
				local tile
				xpcall(function()tile=a.Game.Grid:GetTileAtIndex(Index)end,function(err)warn("Err:",err)end)
				setIdentity(origThreadIdentity)

				if a.Game.LastSelectedIndex ~= nil then
					local searchFor = a.Game.RevealedTiles[a.Game.LastSelectedIndex]
					local dupes = UpdateGameTable(a)
					for i2,v2 in pairs(dupes) do
						if i2 == searchFor and v2.Indexes[1] ~= Index then 
							setIdentity(2)
							tile = a.Game.Grid:GetTileAtIndex(v2.Indexes[1]) 
							setIdentity(origThreadIdentity)
							break 
						end
					end
				else
					local dupes = UpdateGameTable(a)
					for i,v in pairs(dupes) do
						if #v.Indexes > 1 then
							setIdentity(2)
							MemoryMatchModule.RegisterTileSelected(a.Game, a.Game.Grid:GetTileAtIndex(v.Indexes[1]))
							setIdentity(origThreadIdentity)
							repeat task.wait() until a.Game.Grid.InputActive or a.Game.Chances <= 0
							setIdentity(2)
							tile = a.Game.Grid:GetTileAtIndex(v.Indexes[2])
							setIdentity(origThreadIdentity)
							task.wait()
							break
						end
					end
				end
				setIdentity(2)
				MemoryMatchModule.RegisterTileSelected(a.Game, tile)
				setIdentity(origThreadIdentity)
				repeat task.wait() until a.Game.Grid.InputActive or a.Game.Chances <= 0
				task.wait()
			end
			warn("Finishing memory Match")
			Events.ClientCall("MemoryMatchEvent", {
				Action = "Finish"
			})
			warn("Ending Game")
			setIdentity(2)
			MinigameGui.EndGame()
			setIdentity(origThreadIdentity)
			warn("Game ended successfully")
			temptable.activeMemoryMatch = nil
		end
		local hookedMemoryMatchStartGame; hookedMemoryMatchStartGame = hookfunction(MemoryMatchStartGame, function(...)
			local a = hookedMemoryMatchStartGame(...)
			coroutine.wrap(function() task.wait(1) newMemoryMatchStartGame(a) end)()
			return a
		end)
	end)()
end

function hiddenQuestWebhookListener(isPoolQuest, arg1)
	task.wait(3)
	if not vitaly.webhookSettings.sendQuests then return end

	local fullQuest = (not isPoolQuest and getQuestInfo(arg1)) or nil
	local originalNPC = (not isPoolQuest and fullQuest and fullQuest.NPC) or arg1
	local NPC = originalNPC
	local QuestName = (not isPoolQuest and fullQuest and fullQuest.DisplayName) or nil

	local polarPower = tostring(getClientStatCache("Modifiers", "MaxBeeEnergy", "_", "Mods", 1, "Combo") or 0)
	local questCount = tostring(getClientStatCache("Totals", "QuestPoolCounts", originalNPC) or 0)
	pcall(function() NPC = originalNPC:gsub("Bear 2", "Bear") end)

	if isPoolQuest then
		local temp = getClientStatCache("Quests", "PoolLastQuests", tostring(originalNPC))
		local tempQuestInfo = getQuestInfo(temp)
		if temp then QuestName = (tempQuestInfo.DisplayName or tempQuestInfo.Name) end
	end

	local suffix = 
		(NPC=="Polar Bear" and "\n\n"..miscEmojis["Polar Power"].." x"..polarPower) or 
		("\n\n"..(tonumber(questCount) and "Total "..NPC.."'s quests completed: "..questCount) or "...")

	local fields = {}

	if isPoolQuest then
		table.insert(fields,{
			name = "Completed Repeatable Quest",
			value = (QuestName or NPC)..suffix
		})
	else
		table.insert(fields,{
			name = "Completed Quest",
			value = QuestName
		})
	end

	questWebhook(NPC, fields)
end

getgenv().questWebhookListener = setmetatable({Active = true}, {
	__index = function(tbl, key) 
		if key == "HiddenListener" then
			return hiddenQuestWebhookListener
		else
			return rawget(tbl, key)
		end
	end
})

if false then

	if not getgenv().questListener then
		getgenv().questListener = true

		LPH_NO_VIRTUALIZE(function()
			local a = require(game:GetService("ReplicatedStorage").Events)
			local oldClientCall
			oldClientCall = hookfunction(a.ClientCall, function(...)
				local event, arg1 = ...
				if event == "CompleteQuest" or event == "CompleteQuestFromPool" then
					xpcall(function()
						coroutine.wrap(function(event, arg1) 
							setIdentity(8)
							questWebhookListener.HiddenListener((event == "CompleteQuest" and false) or true, arg1)
						end)(event, arg1)
					end, function(err) if vitaly.webhookSettings.sendQuests then warn("Cannot send ") end end)
				end
				return oldClientCall(...)
			end)
		end)()
	end

end

function placeSprinkler(position, withoutWait, withoutJump)
	-- Place a sprinkler at the specified position
	local humanoid = api.humanoid()
	if position then
		local temp1 = nil
		task.spawn(function() temp1 = walkTo(position, 2) end)
		repeat task.wait() until temp1 ~= nil
	end

	if not withoutJump then
		task.wait(.1)
		humanoid.Jump = true
		task.wait(.2)
	end
	PlayerActivesCommand:FireServer({["Name"] = "Sprinkler Builder"})
	if not withoutWait then
		task.wait(1)
	end
end

local sprinklerCounts = {
	["The Supreme Saturator"] = 1,
	["Basic Sprinkler"] = 1,
	["Silver Soakers"] = 2,
	["Golden Gushers"] = 3,
	["Diamond Drenchers"] = 4
}

function placeSprinklers(fieldPos)
	if not fieldPos then return end
	print("sprinklers")
	local sprinkler = getClientStatCache("EquippedSprinkler")
	local flowerSize = 4

	local sprinklersToPlace = sprinklerCounts[sprinkler] or 0
	local placedSprinklersCount = 0

	local centerPos = fieldPos

	for _,v in pairs(Workspace.Gadgets:GetChildren()) do
		if v.Name == sprinkler and isFieldSame(centerPos, v.Base.Position) then
			placedSprinklersCount += 1
		end
	end

	if placedSprinklersCount >= sprinklersToPlace then return  end

	if sprinklersToPlace == 1 then
		placeSprinkler(centerPos, true, true)
	elseif sprinklersToPlace == 2 then
		placeSprinkler(centerPos + Vector3.new(-3*flowerSize, 0, -3*flowerSize))
		placeSprinkler(centerPos + Vector3.new(3*flowerSize, 0, 3*flowerSize), true, false)
	elseif sprinklersToPlace == 3 then
		placeSprinkler(centerPos + Vector3.new(3*flowerSize, 0, -3*flowerSize))
		placeSprinkler(centerPos + Vector3.new(-4*flowerSize, 0, -3*flowerSize))
		placeSprinkler(centerPos + Vector3.new(0*flowerSize, 0, 3*flowerSize), true, false)
	elseif sprinklersToPlace == 4 then
		placeSprinkler(centerPos + Vector3.new(-4*flowerSize, 0, 0*flowerSize))
		placeSprinkler(centerPos + Vector3.new(4*flowerSize, 0, 0*flowerSize))
		placeSprinkler(centerPos + Vector3.new(0*flowerSize, 0, 4*flowerSize))
		placeSprinkler(centerPos + Vector3.new(0*flowerSize, 0, -4*flowerSize), true, false)
	end
end

function getBeeRarity(beeName)
	local fullBeeData = beesTable.fullData[beeName:gsub(" Bee", "")]
	if fullBeeData then return fullBeeData.Rarity end
	return ""
end

function isBeeExpected(beeCell)
	local beeName = beeCell.CellType.Value:gsub("Bee", " Bee")
	local beeRarity = getBeeRarity(beeName)
	local isGifted = beeCell:FindFirstChild("GiftedCell") and true or false

	local stop = false

	if temptable.autoRJSettings.requireAnyGifted and isGifted then 
		stop = true 
	end

	if table.find(temptable.autoRJSettings.selectedRarities, "Any "..beeRarity) or table.find(temptable.autoRJSettings.selectedRarities, "Gifted Any "..beeRarity) and isGifted then
		stop = true
	end

	if table.find(temptable.autoRJSettings.selectedBees, beeName) or table.find(temptable.autoRJSettings.selectedBees, "Gifted "..beeName) and isGifted then
		stop = true
	end
	return stop
end




local Window = Fluent:CreateWindow({
	Title = "vitaly",
	SubTitle = "",
	TabWidth = 140,
	TabHeight = 80,
	Size = UDim2.fromOffset(650, 350),
	Acrylic = true,
	Theme = "Dark",
	MinimizeKey = Enum.KeyCode.RightShift
})


local Tabs = {
	Home = Window:AddTab({ Title = "Home", Icon = "home" }),
	Farming = Window:AddTab({ Title = "Farming", Icon = "bot" }),
	Combat = Window:AddTab({ Title = "Combat", Icon = "swords" }),
	AutoQuest = Window:AddTab({ Title = "Auto Quest", Icon = "book" }),
	Planters = Window:AddTab({ Title = "Planters", Icon = "sprout" }),
	Puffshrooms = Window:AddTab({ Title = "Puffshrooms", Icon = "biohazard" }),
	Misc = Window:AddTab({ Title = "Miscellaneous", Icon = "sprout" }),
	Webhook = Window:AddTab({ Title = "Discord Webhook", Icon = "sprout" }),
	Settings = Window:AddTab({ Title = "Settings", Icon = "sprout" }),
	Config = Window:AddTab({ Title = "Config", Icon = "settings" }),
	Premium = Window:AddTab({ Title = "Premium", Icon = "star" })
}


local Options = Fluent.Options


Fluent:Notify({
	Title = "Fluent",
	Content = "The script has been loaded.",
	Duration = 8
})

Window:SelectTab(1)
local homeTab = Tabs.Home
local informationSection = homeTab:AddSection("Information")

informationSection:AddButton({
	Title = "Redeem Codes",
	Tooltip = "",
	Callback = function() 
		for _, code in pairs(temptable.codesTable) do
			Events.ClientCall("PromoCodeEvent", code)
			task.wait(0.5)
		end
	end
})

informationSection:AddToggle("StopEverythingToggle", {
	Title = "Stop Everything",
	Description = "",
	Default = false,
	Callback = function(state)
		temptable.stopEverything = state
	end
})


local farmingTab = Tabs.Farming

farmingTab:AddDropdown("Farming Field", {
	Title = "Select Farming Field",
	Values = fieldsTable,
	Multi = false,
	Default = vitaly.autoFarmSettings.field,
	Callback = function(selected)
		vitaly.autoFarmSettings.field = selected
	end
})

farmingTab:AddToggle("Autofarm [âš™]", {
	Title = "Toggle Autofarm",
	Default = vitaly.toggles.autofarm,
	Callback = function(State)
		vitaly.toggles.autofarm = State
		if State then
			Tasks:Add("Autofarm", mainAutofarmFunction, true)
		else
			if Tasks:Get("Autofarm") then Tasks:Cancel("Autofarm") end
			player.DevComputerMovementMode = Enum.DevComputerMovementMode.UserChoice
		end
	end
})

farmingTab:AddToggle("Auto Sprinkler", {
	Title = "Toggle Auto Sprinkler",
	Default = vitaly.autoFarmSettings.autoSprinkler or true,
	Callback = function(State)
		vitaly.autoFarmSettings.autoSprinkler = State
	end
})

farmingTab:AddToggle("Auto Dig", {
	Title = "Toggle Auto Dig",
	Default = vitaly.toggles.autodig,
	Callback = function(State)
		vitaly.toggles.autodig = State
		if State then
			Tasks:Add("Auto Dig", function()
				while task.wait(0.03) do
					local success, errorMsg = pcall(function()
						dig()
					end)
					if not success then
						error(errorMsg)
					end
				end
			end, true)
		else
			if Tasks:Get("Auto Dig") then
				Tasks:Cancel("Auto Dig")
			end
		end
	end
})



local farmingTab = Tabs.Farming

farmingTab:AddToggle("ignoreHoneyTokens", {
	Title = "Ignore Honey Tokens",
	Default = vitaly.autoFarmSettings.ignoreHoneyTokens,
	Callback = function(state)
		vitaly.autoFarmSettings.ignoreHoneyTokens = state
	end
})

farmingTab:AddToggle("farmFlames", {
	Title = "Farm Flames",
	Default = vitaly.autoFarmSettings.farmFlames,
	Callback = function(state)
		vitaly.autoFarmSettings.farmFlames = state
	end
})

-- Toggle: Farm Bubbles
farmingTab:AddToggle("farmBubbles", {
	Title = "Farm Bubbles",
	Default = vitaly.autoFarmSettings.farmBubbles,
	Callback = function(state)
		vitaly.autoFarmSettings.farmBubbles = state
	end
})

-- Toggle: Farm Fuzzy Bombs
farmingTab:AddToggle("farmFuzzyBombs", {
	Title = "Farm Fuzzy Bombs",
	Default = vitaly.autoFarmSettings.farmFuzzyBombs,
	Callback = function(state)
		vitaly.autoFarmSettings.farmFuzzyBombs = state
	end
})

-- Toggle: Farm Under Clouds
farmingTab:AddToggle("farmUnderClouds", {
	Title = "Farm Under Clouds",
	Default = vitaly.autoFarmSettings.farmUnderClouds,
	Callback = function(state)
		vitaly.autoFarmSettings.farmUnderClouds = state
	end
})

-- Toggle: Farm Under Balloons
farmingTab:AddToggle("farmUnderBalloons", {
	Title = "Farm Under Balloons",
	Default = vitaly.autoFarmSettings.farmUnderBalloons,
	Callback = function(state)
		vitaly.autoFarmSettings.farmUnderBalloons = state
	end
})

-- Toggle: Farm Shower
farmingTab:AddToggle("farmShower", {
	Title = "Farm Shower",
	Default = vitaly.autoFarmSettings.farmShower,
	Callback = function(state)
		vitaly.autoFarmSettings.farmShower = state
	end
})

-- Toggle: Farm Coconuts
farmingTab:AddToggle("farmCoconuts", {
	Title = "Farm Coconuts",
	Default = vitaly.autoFarmSettings.farmCoconuts,
	Callback = function(state)
		vitaly.autoFarmSettings.farmCoconuts = state
	end
})

-- Toggle: Farm Glitched Tokens
farmingTab:AddToggle("farmDupedTokens", {
	Title = "Farm Glitched Tokens",
	Default = vitaly.autoFarmSettings.farmDupedTokens,
	Callback = function(state)
		vitaly.autoFarmSettings.farmDupedTokens = state
	end
})

-- Toggle: Farm Sprouts
farmingTab:AddToggle("farmSprouts", {
	Title = "Farm Sprouts",
	Default = vitaly.autoFarmSettings.farmSprouts,
	Callback = function(state)
		vitaly.autoFarmSettings.farmSprouts = state
	end
})

-- Toggle: Smart Bubble Bloat
farmingTab:AddToggle("smartBubbleBloat", {
	Title = "Smart Bubble Bloat"..Star,
	Default = vitaly.autoFarmSettings.smartBubbleBloat,
	Callback = function(state)
		vitaly.autoFarmSettings.smartBubbleBloat = state
	end
})

-- Toggle: Smart Precise Crosshair
farmingTab:AddToggle("smartPreciseCrosshair", {
	Title = "Smart Precise Crosshair"..Star,
	Default = vitaly.autoFarmSettings.smartPreciseCrosshair,
	Callback = function(state)
		vitaly.autoFarmSettings.smartPreciseCrosshair = state
	end
})


-- Toggle: Use Instant Conversion
farmingTab:AddToggle("instantToggle", {
	Title = "Use Instant Conversion",
	Default = vitaly.convertSettings.instantToggle,
	Callback = function(state)
		vitaly.convertSettings.instantToggle = state
	end
})


local selectedInstantValues = {}

farmingTab:AddParagraph({
	Title = "Selected Instant Conversion",
	Content = ""
})

for _, option in ipairs(instantConvList) do
	local toggleName = "toggle_" .. option
	local defaultValue = vitaly.convertSettings.selectedInstant and vitaly.convertSettings.selectedInstant[option] or false

	farmingTab:AddToggle(toggleName, {
		Title = option,
		Default = defaultValue,
		Callback = function(state)
			selectedInstantValues[option] = state
			vitaly.convertSettings.selectedInstant = selectedInstantValues
		end
	})
end

-- Optional: Another paragraph for separation (if needed)
farmingTab:AddParagraph({
	Title = "",
	Content = ""
})



-- Toggle: Auto Honey Mask
farmingTab:AddToggle("AutoHoneyM", {
	Title = "Auto Honey Mask",
	Default = vitaly.toggles.AutoHoneyM,
	Callback = function(state)
		vitaly.toggles.AutoHoneyM = state
	end
})


-- Add toggles directly under Tabs.Farming for Automatisation section
Tabs.Farming:AddToggle("autodispensers", {
	Title = "Auto Dispensers",
	Default = vitaly.toggles.autodispensers,
	Callback = function(state)
		vitaly.toggles.autodispensers = state
	end
})

Tabs.Farming:AddToggle("autoboosters", {
	Title = "Auto Boosters",
	Default = vitaly.toggles.autoboosters,
	Callback = function(state)
		vitaly.toggles.autoboosters = state
	end
})

Tabs.Farming:AddToggle("automemorymatch", {
	Title = "Auto Memory Match",
	Default = vitaly.toggles.automemorymatch,
	Callback = function(state)
		vitaly.toggles.automemorymatch = state
	end
})

for i, v in pairs(AllToysTable.toysTable) do
	Tabs.Farming:AddToggle(i, {
		Title = "Auto " .. v,
		Default = vitaly.toggles[i],
		Callback = function(state)
			vitaly.toggles[i] = state
		end
	})
end


local fCenter, fBalloon, fFlame

fCenter = farmingTab:AddToggle("faceCenter", {
	Title = "Face Field Center",
	Default = vitaly.autoFarmSettings.faceCenter,
	Callback = function(state)
		if not state then return end
		fBalloon:SetValue(false)
		fFlame:SetValue(false)
	end
})

fBalloon = farmingTab:AddToggle("faceBalloons", {
	Title = "Face Balloons",
	Default = vitaly.autoFarmSettings.faceBalloons,
	Callback = function(state)
		if not state then return end
		fCenter:SetValue(false)
		fFlame:SetValue(false)
	end
})

fFlame = farmingTab:AddToggle("faceFlames", {
	Title = "Face Flames",
	Default = vitaly.autoFarmSettings.faceFlames,
	Callback = function(state)
		if not state then return end
		fCenter:SetValue(false)
		fBalloon:SetValue(false)
	end
})

local combatTab = Tabs.Combat

Tabs.Combat:AddToggle("trainCrab", {
	Title = "Auto kill Crab",
	Default = vitaly.combatSettings.trainCrab,
	Callback = function(state)
		vitaly.combatSettings.trainCrab = state
	end
})

Tabs.Combat:AddToggle("trainKingBeetle", {
	Title = "Auto kill King Beetle",
	Default = vitaly.combatSettings.trainKingBeetle,
	Callback = function(state)
		vitaly.combatSettings.trainKingBeetle = state
	end
})

Tabs.Combat:AddToggle("trainTunnelBear", {
	Title = "Auto kill Tunnel Bear",
	Default = vitaly.combatSettings.trainTunnelBear,
	Callback = function(state)
		vitaly.combatSettings.trainTunnelBear = state
	end
})

Tabs.Combat:AddToggle("trainStumpSnail", {
	Title = "Auto kill Stump Snail",
	Default = vitaly.combatSettings.trainStumpSnail,
	Callback = function(state)
		vitaly.combatSettings.trainStumpSnail = state
	end
})

Tabs.Combat:AddToggle("snailConvertHoney", {
	Title = "Convert Honey (When killing Snail)",
	Default = vitaly.combatSettings.snailConvertHoney,
	Callback = function(state)
		vitaly.combatSettings.snailConvertHoney = state
	end
})

Tabs.Combat:AddToggle("killSpidor", {
	Title = "Auto kill Spider",
	Default = vitaly.combatSettings.killSpidor,
	Callback = function(state)
		vitaly.combatSettings.killSpidor = state
	end
})

Tabs.Combat:AddToggle("killMantis", {
	Title = "Auto kill Mantis",
	Default = vitaly.combatSettings.killMantis,
	Callback = function(state)
		vitaly.combatSettings.killMantis = state
	end
})

Tabs.Combat:AddToggle("killScorpion", {
	Title = "Auto kill Scorpion",
	Default = vitaly.combatSettings.killScorpion,
	Callback = function(state)
		vitaly.combatSettings.killScorpion = state
	end
})

Tabs.Combat:AddToggle("killWerewolf", {
	Title = "Auto kill Werewolf",
	Default = vitaly.combatSettings.killWerewolf,
	Callback = function(state)
		vitaly.combatSettings.killWerewolf = state
	end
})


Tabs.Combat:AddToggle("killVicious", {
	Title = "Auto Vicious",
	Default = vitaly.combatSettings.killVicious,
	Callback = function(state)
		vitaly.combatSettings.killVicious = state
	end
})

Tabs.Combat:AddSlider("viciousMinLevel", {
	Title = "Minimum Level",
	Min = 1,
	Max = 12,
	Rounding = 1,
	Default = vitaly.combatSettings.viciousMinLevel,
	Callback = function(value)
		vitaly.combatSettings.viciousMinLevel = value
	end
})

Tabs.Combat:AddSlider("viciousMaxLevel", {
	Title = "Maximum Level",
	Min = 1,
	Max = 12,
	Rounding = 1,
	Default = vitaly.combatSettings.viciousMaxLevel,
	Callback = function(value)
		vitaly.combatSettings.viciousMaxLevel = value
	end
})


local autoQuestTab = Tabs.AutoQuest

autoQuestTab:AddToggle("doQuests", {
	Title = "Auto Quests",
	Default = vitaly.autoQuestSettings.doQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.doQuests = state
	end
})

autoQuestTab:AddToggle("doRepeatables", {
	Title = "Auto Repeatable Quests",
	Default = vitaly.autoQuestSettings.doRepeatables,
	Callback = function(state)
		vitaly.autoQuestSettings.doRepeatables = state
	end
}):SetValue(true)

autoQuestTab:AddToggle("acceptAllQuests", {
	Title = "Accept All Quests",
	Default = vitaly.autoQuestSettings.acceptAllQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.acceptAllQuests = state
	end
})

autoQuestTab:AddParagraph({
	Title = "",
	Content = ""
})

autoQuestTab:AddToggle("BlackBearQuests", {
	Title = "Black Bear Quests",
	Default = vitaly.autoQuestSettings.BlackBearQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.BlackBearQuests = state
	end
})

autoQuestTab:AddToggle("BrownBearQuests", {
	Title = "Brown Bear Quests",
	Default = vitaly.autoQuestSettings.BrownBearQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.BrownBearQuests = state
	end
})

autoQuestTab:AddToggle("PandaBearQuests", {
	Title = "Panda Bear Quests",
	Default = vitaly.autoQuestSettings.PandaBearQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.PandaBearQuests = state
	end
})

autoQuestTab:AddToggle("ScienceBearQuests", {
	Title = "Science Bear Quests",
	Default = vitaly.autoQuestSettings.ScienceBearQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.ScienceBearQuests = state
	end
})

autoQuestTab:AddToggle("PolarBearQuests", {
	Title = "Polar Bear Quests",
	Default = vitaly.autoQuestSettings.PolarBearQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.PolarBearQuests = state
	end
})

autoQuestTab:AddToggle("SpiritsBearQuests", {
	Title = "Spirit Bear Quests",
	Default = vitaly.autoQuestSettings.SpiritsBearQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.SpiritsBearQuests = state
	end
})

autoQuestTab:AddToggle("BuckoBeeQuests", {
	Title = "Bucko Bee Quests",
	Default = vitaly.autoQuestSettings.BuckoBeeQuests,
	vitaly = function(state)
		vitaly.autoQuestSettings.BuckoBeeQuests = state
	end
})

autoQuestTab:AddToggle("RileyBeeQuests", {
	Title = "Riley Bee Quests",
	Default = vitaly.autoQuestSettings.RileyBeeQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.RileyBeeQuests = state
	end
})

autoQuestTab:AddToggle("HoneyBeeQuests", {
	Title = "Honey Bee Quests",
	Default = vitaly.autoQuestSettings.HoneyBeeQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.HoneyBeeQuests = state
	end
})

autoQuestTab:AddToggle("OnettQuests", {
	Title = "Onett Quests",
	Default = vitaly.autoQuestSettings.OnettQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.OnettQuests = state
	end
})

if scriptType == LPH_STRENC("Paid") then
	autoQuestTab:AddToggle("BeeBearQuests", {
		Title = "Bee Bear Quests "..Star,
		Default = vitaly.autoQuestSettings.BeeBearQuests,
		Callback = function(state)
			vitaly.autoQuestSettings.BeeBearQuests = state
		end
	})
end

autoQuestTab:AddParagraph({
	Title = "",
	Content = ""
})

autoQuestTab:AddParagraph({
	Title = "Quests Settings",
	Content = ""
})

autoQuestTab:AddToggle("tpToNPC", {
	Title = "Teleport to npc",
	Default = vitaly.autoQuestSettings.tpToNPC,
	Callback = function(state)
		vitaly.autoQuestSettings.tpToNPC = state
	end
})

autoQuestTab:AddToggle("farmPollen", {
	Title = "Do Pollen Quests",
	Default = vitaly.autoQuestSettings.farmPollen,
	Callback = function(state)
		vitaly.autoQuestSettings.farmPollen = state
	end
})

autoQuestTab:AddToggle("farmGoo", {
	Title = "Do Goo Quests",
	Default = vitaly.autoQuestSettings.farmGoo,
	Callback = function(state)
		vitaly.autoQuestSettings.farmGoo = state
	end
})

autoQuestTab:AddToggle("killMobs", {
	Title = "Kill Mobs For Quests",
	Default = vitaly.autoQuestSettings.killMobs,
	Callback = function(state)
		vitaly.autoQuestSettings.killMobs = state
	end
})

autoQuestTab:AddToggle("feedBees", {
	Title = "Feed Bees For Quests",
	Default = vitaly.autoQuestSettings.feedBees,
	Callback = function(state)
		vitaly.autoQuestSettings.feedBees = state
	end
})

autoQuestTab:AddToggle("useToys", {
	Title = "Use Toys For Quests",
	Default = vitaly.autoQuestSettings.useToys,
	Callback = function(state)
		vitaly.autoQuestSettings.useToys = state
	end
})

autoQuestTab:AddToggle("useMemoryMatch", {
	Title = "Do Memory Match Quests",
	Default = vitaly.autoQuestSettings.useMemoryMatch,
	Callback = function(state)
		vitaly.autoQuestSettings.useMemoryMatch = state
	end
})

autoQuestTab:AddToggle("doQuestQuests", {
	Title = "Do Quests For Quests",
	Default = vitaly.autoQuestSettings.doQuestQuests,
	Callback = function(state)
		vitaly.autoQuestSettings.doQuestQuests = state
	end
})

autoQuestTab:AddParagraph({
	Title = "",
	Content = ""
})

autoQuestTab:AddParagraph({
	Title = "Quests Farm Settings",
	Content = ""
})

autoQuestTab:AddDropdown("bestBlueField", {
	Title = "Best Field for Blue Pollen",
	Values = blueFields,
	Default = vitaly.autoQuestSettings.bestBlueField,
	Callback = function(selected)
		vitaly.autoQuestSettings.bestBlueField = selected
	end
})

autoQuestTab:AddDropdown("bestRedField", {
	Title = "Best Field for Red Pollen",
	Values = redFields,
	Default = vitaly.autoQuestSettings.bestRedField,
	Callback = function(selected)
		vitaly.autoQuestSettings.bestRedField = selected
	end
})

autoQuestTab:AddDropdown("bestWhiteField", {
	Title = "Best Field for White Pollen",
	Values = whiteFields,
	Default = vitaly.autoQuestSettings.bestWhiteField,
	Callback = function(selected)
		vitaly.autoQuestSettings.bestWhiteField = selected
	end
})

autoQuestTab:AddParagraph({
	Title = "",
	Content = ""
})

autoQuestTab:AddParagraph({
	Title = "Quests Priority Settings",
	Content = ""
})

autoQuestTab:AddToggle("prioritizeMobKill", {
	Title = "Prioritize Mob Kill Quests",
	Default = vitaly.autoQuestSettings.prioritizeMobKill,
	Callback = function(state)
		vitaly.autoQuestSettings.prioritizeMobKill = state
	end
}):SetValue(true)

autoQuestTab:AddToggle("enablePriorities", {
	Title = "Enable NPC Priorities",
	Default = vitaly.autoQuestSettings.enablePriorities,
	Callback = function(state)
		vitaly.autoQuestSettings.enablePriorities = state
	end
})

autoQuestTab:AddDropdown("selectedPriorityNpc", {
	Title = "Select NPC",
	Values = npcsTable,
	Default = "Polar Bear",
	Callback = function(selectedNpc)
		if temptable.selectedPriorityNpc == selectedNpc then return end
		temptable.selectedPriorityNpc = selectedNpc
		local npcPriority = getQuestSetting(selectedNpc, "prio")
		temptable.npcPrioSlider:SetValue(tonumber(npcPriority))
	end
})

autoQuestTab:AddSlider("npcPrioSlider", {
	Title = "Select Npc Priority",
	Min = 1,
	Max = 15,
	Default = 1,
	Rounding = 0,
	Callback = function(newPrio)
		if temptable.selectedPriorityNpc == "Bee Bear 5" then
			vitaly.autoQuestSettings.BeeBearPriority = newPrio
		else
			pcall(function()
				vitaly.autoQuestSettings[temptable.selectedPriorityNpc:gsub(" ","").."Priority"] = newPrio
			end)
		end
	end
})

local plantersTab = Tabs.Planters

local autoPlantersNectarsSection = plantersTab:AddParagraph({
	Title = "Automatic Planters & Nectars",
	Content = ""
})

plantersTab:AddToggle("doCustomPlanters", {
	Title = "Do Custom Planters",
	Default = vitaly.autoPlantersSettings.doCustomPlanters,
	Callback = function(state)
		vitaly.autoPlantersSettings.doCustomPlanters = state
	end
})

local customFieldDropdown = table.clone(fieldsTable)
local customPlanterDropdown = table.clone(plantersDropdownTable)
table.insert(customFieldDropdown, "None")
table.insert(customPlanterDropdown, "None")
local customPlanterSections = {
	customPlanters1 = {},
	customPlanters2 = {},
	customPlanters3 = {}
}

for i = 1, 3 do
	local cycleName = "customPlanters" .. i
	local cycleTable = vitaly.customPlanterSettings[cycleName]

	plantersTab:AddParagraph({
		Title = "Custom Planters " .. tostring(i),
		Content = "",
		Color = Color3.fromRGB(255, 0, 0)  -- Red color for visibility
	})

	customPlanterSections[cycleName].section = plantersTab

	for cycleStep = 1, 5 do
		local stepConfig = cycleTable[cycleStep]

		if not customPlanterSections[cycleName][cycleStep] then 
			customPlanterSections[cycleName][cycleStep] = {} 
		end

		local planterDropdown = customPlanterSections[cycleName].section:AddDropdown("Field "..cycleStep.." Planter", {
			Title = "Field " .. cycleStep .. " Planter",
			Values = customPlanterDropdown,
			Default = "None",
			Callback = function(newPlanter) 
				vitaly["customPlanterSettings"][cycleName][cycleStep].planter = newPlanter
			end
		})

		local fieldDropdown = customPlanterSections[cycleName].section:AddDropdown("Field "..cycleStep, {
			Title = "Field " .. cycleStep,
			Values = customFieldDropdown,
			Default = "None",
			Callback = function(newField) 
				vitaly["customPlanterSettings"][cycleName][cycleStep].field = newField
			end
		})

		local harvestSlider = customPlanterSections[cycleName].section:AddSlider("Field "..cycleStep.." Harvest %", {
			Title = "Field " .. cycleStep .. " Harvest %",
			Min = 1,
			Max = 100,
			Default = 75,
			Rounding = 0,
			Callback = function(newPercentage) 
				vitaly["customPlanterSettings"][cycleName][cycleStep].harvestAmount = newPercentage 
			end
		})

		-- Set initial values or defaults
		planterDropdown:SetValue("None")
		fieldDropdown:SetValue("None")
		harvestSlider:SetValue(75)

		if cycleStep < 5 then
			plantersTab:AddParagraph({
				Title = "",
				Content = ""
			})
		end
	end
end


if scriptType == LPH_STRENC("Paid") then
	local puffshroomsTab = Tabs.Puffshrooms

	puffshroomsTab:AddToggle("farmPuffshrooms", {
		Title = "Farm Puffshrooms",
		Default = vitaly.autoPuffshroomSettings.farmPuffshrooms,
		Callback = function(state)
			vitaly.autoPuffshroomSettings.farmPuffshrooms = state
		end
	})

	puffshroomsTab:AddSlider("minimumLevel", {
		Title = "Minimum Level",
		Min = 1,
		Max = 15,
		Rounding = 1,
		Default = vitaly.autoPuffshroomSettings.minimumLevel,
		Callback = function(newValue)
			vitaly.autoPuffshroomSettings.minimumLevel = newValue
		end
	})

	puffshroomsTab:AddSlider("maximumLevel", {
		Title = "Maximum Level",
		Min = 1,
		Max = 30,
		Rounding = 1,
		Default = vitaly.autoPuffshroomSettings.maximumLevel,
		Callback = function(newValue)
			vitaly.autoPuffshroomSettings.maximumLevel = newValue
		end
	})

	puffshroomsTab:AddToggle("farmRemaining", {
		Title = "Farm Remaining Puffs",
		Default = vitaly.autoPuffshroomSettings.farmRemaining,
		Callback = function(state)
			vitaly.autoPuffshroomSettings.farmRemaining = state
		end
	})

	-- Puffshroom Priority Settings
	puffshroomsTab:AddParagraph({
		Title = "Puffshroom Priority Settings " .. Star,
		Content = ""
	})

	puffshroomsTab:AddDropdown("rarityPriority", {
		Title = "Puffshroom Rarity",
		Values = {"Mythic > Common", "Common > Mythic"},
		Default = vitaly.autoPuffshroomSettings.rarityPriority,
		Callback = function(selected)
			vitaly.autoPuffshroomSettings.rarityPriority = selected
		end
	})

	puffshroomsTab:AddDropdown("levelPriority", {
		Title = "Puffshroom Level",
		Values = {"High > Low", "Low > High"},
		Default = vitaly.autoPuffshroomSettings.levelPriority,
		Callback = function(selected)
			vitaly.autoPuffshroomSettings.levelPriority = selected
		end
	})
end




LPH_NO_VIRTUALIZE(function()
	local temp1 = 0
	getgenv().hide = function(ok)
		for __, v in pairs(ok:GetChildren()) do
			temp1 = temp1 + 1
			if temp1 % 100 == 0 then task.wait() end
			if v.Name == "Gates" then continue end
			pcall(function()
				if v.ClassName == "Decal" then
					v:Destroy()
				else
					v.Material = "Plastic"
				end
			end)
			getgenv().hide(v)
		end
	end
end)()

local miscellaneousTab = Tabs.Misc

miscellaneousTab:AddToggle("True/False", {
	Title = "enable Rendering",
	Default = true,
	Callback = function(state)
		game:GetService("RunService"):Set3dRenderingEnabled(state)
	end
})

local settingsTab = Tabs.Settings

-- AutoFarm settings Section
settingsTab:AddSlider("convertat", {
	Title = "Convert Honey At",
	Min = 0,
	Max = 100,
	Rounding = 0,

	Default = vitaly.convertSettings.convertat,
	Callback = function(newValue)
		vitaly.convertSettings.convertat = newValue
	end
})

settingsTab:AddToggle("converthiveballoon", {
	Title = "Convert Hive Balloon",
	Default = true,
	Callback = function(state)
		vitaly.convertSettings.converthiveballoon = state
	end
})

settingsTab:AddSlider("convertballoonat", {
	Title = "Convert Balloon At (blessing minutes)",
	Min = 0,
	Max = 60,
	Rounding = 0,

	Default = vitaly.convertSettings.convertballoonat,
	Callback = function(newValue)
		vitaly.convertSettings.convertballoonat = newValue
	end
})

settingsTab:AddSlider("secondsBeforeConvert", {
	Title = "Farm In Field When Full",
	Min = 0,
	Max = 60,
	Rounding = 0,

	Default = vitaly.convertSettings.secondsBeforeConvert,
	Callback = function(newValue)
		vitaly.convertSettings.secondsBeforeConvert = newValue
	end
})

settingsTab:AddToggle("convertHoney", {
	Title = "Convert Honey",
	Default = true,
	Callback = function(state)
		vitaly.convertSettings.convertHoney = state
	end
})

-- Local Player Settings Section
settingsTab:AddSlider("walkSpeed", {
	Title = "Walk Speed",
	Min = 20,
	Max = 90,
	Rounding = 0,

	Default = vitaly.localPlayerSettings.walkSpeed,
	Callback = function(newValue)
		vitaly.localPlayerSettings.walkSpeed = newValue
	end
})

settingsTab:AddSlider("tweenSpeed", {
	Title = "Tween Speed",
	Min = 1,
	Max = 12,
	Rounding = 0,
	Default = vitaly.localPlayerSettings.tweenSpeed,
	Callback = function(newValue)
		vitaly.localPlayerSettings.tweenSpeed = newValue
	end
})

settingsTab:AddToggle("speedhack", {
	Title = "Speedhack",
	Callback = function(state)
		vitaly.toggles.speedhack = state
	end
})

Tasks:Add("Walk Speed", function()
	while task.wait() do
		if temptable.customWalkSpeed.enabled then
			api.humanoid().WalkSpeed = temptable.customWalkSpeed.speed
		else
			if vitaly.toggles.speedhack then
				local newSpeed = vitaly.localPlayerSettings.walkSpeed
				pcall(function()
					local systemSpeed = getClientStatCache("ModifierCaches", "Value", "PlayerMovespeed", "_")
					if tonumber(systemSpeed) and systemSpeed > newSpeed then
						newSpeed = systemSpeed
					end
				end)
				pcall(function()
					player.Character.Humanoid.WalkSpeed = newSpeed
				end)
			end
		end
	end
end, true)

settingsTab:AddToggle("hideDecorations", {
	Title = "Hide Decorations",
	Callback = function(state)
		if state then
			temptable.fieldDecosFolder.Parent = ReplicatedStorage
		else
			temptable.fieldDecosFolder.Parent = Workspace
		end
	end
})
local raresSettingsSection = settingsTab:AddSection("Rares Settings" )

raresSettingsSection:AddToggle("BitterberryToggle", {
	Title = "Bitterberry",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Bitterberry")
		else
			local index = table.find(vitaly.vars.rares, "Bitterberry")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})
-- Toggle: Blue Extract
raresSettingsSection:AddToggle("Blue ExtractToggle", {
	Title = "Blue Extract",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Blue Extract")
		else
			local index = table.find(vitaly.vars.rares, "Blue Extract")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Blueberry
raresSettingsSection:AddToggle("BlueberryToggle", {
	Title = "Blueberry",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Blueberry")
		else
			local index = table.find(vitaly.vars.rares, "Blueberry")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Coconut
raresSettingsSection:AddToggle("CoconutToggle", {
	Title = "Coconut",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Coconut")
		else
			local index = table.find(vitaly.vars.rares, "Coconut")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Diamond Egg
raresSettingsSection:AddToggle("Diamond EggToggle", {
	Title = "Diamond Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Diamond Egg")
		else
			local index = table.find(vitaly.vars.rares, "Diamond Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Enzymes
raresSettingsSection:AddToggle("Enzymes", {
	Title = "Enzymes",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Diamond Egg")
		else
			local index = table.find(vitaly.vars.rares, "Diamond Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})
raresSettingsSection:AddToggle("Festive BeanToggle", {
	Title = "Festive Bean",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Festive Bean")
		else
			local index = table.find(vitaly.vars.rares, "Festive Bean")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})
raresSettingsSection:AddToggle("Gifted Diamond EggToggle", {
	Title = "Gifted Diamond Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Gifted Diamond Egg")
		else
			local index = table.find(vitaly.vars.rares, "Gifted Diamond Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})
raresSettingsSection:AddToggle("Gifted Gold EggToggle", {
	Title = "Gifted Gold Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Gifted Gold Egg")
		else
			local index = table.find(vitaly.vars.rares, "Gifted Gold Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Gifted Mythic Egg
raresSettingsSection:AddToggle("Gifted Mythic EggToggle", {
	Title = "Gifted Mythic Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Gifted Mythic Egg")
		else
			local index = table.find(vitaly.vars.rares, "Gifted Mythic Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Gifted Silver Egg
raresSettingsSection:AddToggle("Gifted Silver EggToggle", {
	Title = "Gifted Silver Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Gifted Silver Egg")
		else
			local index = table.find(vitaly.vars.rares, "Gifted Silver Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Gingerbread Bear
raresSettingsSection:AddToggle("Gingerbread BearToggle", {
	Title = "Gingerbread Bear",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Gingerbread Bear")
		else
			local index = table.find(vitaly.vars.rares, "Gingerbread Bear")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Glitter
raresSettingsSection:AddToggle("GlitterToggle", {
	Title = "Glitter",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Glitter")
		else
			local index = table.find(vitaly.vars.rares, "Glitter")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Glue
raresSettingsSection:AddToggle("GlueToggle", {
	Title = "Glue",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Glue")
		else
			local index = table.find(vitaly.vars.rares, "Glue")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Gold Egg
raresSettingsSection:AddToggle("Gold EggToggle", {
	Title = "Gold Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Gold Egg")
		else
			local index = table.find(vitaly.vars.rares, "Gold Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})
-- Toggle: Honeysuckle
raresSettingsSection:AddToggle("HoneysuckleToggle", {
	Title = "Honeysuckle",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Honeysuckle")
		else
			local index = table.find(vitaly.vars.rares, "Honeysuckle")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Moon Charm
raresSettingsSection:AddToggle("Moon CharmToggle", {
	Title = "Moon Charm",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Moon Charm")
		else
			local index = table.find(vitaly.vars.rares, "Moon Charm")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Mythic Egg
raresSettingsSection:AddToggle("Mythic EggToggle", {
	Title = "Mythic Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Mythic Egg")
		else
			local index = table.find(vitaly.vars.rares, "Mythic Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Neonberry
raresSettingsSection:AddToggle("NeonberryToggle", {
	Title = "Neonberry",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Neonberry")
		else
			local index = table.find(vitaly.vars.rares, "Neonberry")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Night Bell
raresSettingsSection:AddToggle("Night BellToggle", {
	Title = "Night Bell",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Night Bell")
		else
			local index = table.find(vitaly.vars.rares, "Night Bell")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Oil
raresSettingsSection:AddToggle("OilToggle", {
	Title = "Oil",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Oil")
		else
			local index = table.find(vitaly.vars.rares, "Oil")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Pineapple
raresSettingsSection:AddToggle("PineappleToggle", {
	Title = "Pineapple",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Pineapple")
		else
			local index = table.find(vitaly.vars.rares, "Pineapple")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Red Extract
raresSettingsSection:AddToggle("Red ExtractToggle", {
	Title = "Red Extract",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Red Extract")
		else
			local index = table.find(vitaly.vars.rares, "Red Extract")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Silver Egg
raresSettingsSection:AddToggle("Silver EggToggle", {
	Title = "Silver Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Silver Egg")
		else
			local index = table.find(vitaly.vars.rares, "Silver Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Soft Wax
raresSettingsSection:AddToggle("Soft WaxToggle", {
	Title = "Soft Wax",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Soft Wax")
		else
			local index = table.find(vitaly.vars.rares, "Soft Wax")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Star Egg
raresSettingsSection:AddToggle("Star EggToggle", {
	Title = "Star Egg",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Star Egg")
		else
			local index = table.find(vitaly.vars.rares, "Star Egg")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Star Jelly
raresSettingsSection:AddToggle("Star JellyToggle", {
	Title = "Star Jelly",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Star Jelly")
		else
			local index = table.find(vitaly.vars.rares, "Star Jelly")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Star Treat
raresSettingsSection:AddToggle("Star TreatToggle", {
	Title = "Star Treat",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Star Treat")
		else
			local index = table.find(vitaly.vars.rares, "Star Treat")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Stinger
raresSettingsSection:AddToggle("StingerToggle", {
	Title = "Stinger",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Stinger")
		else
			local index = table.find(vitaly.vars.rares, "Stinger")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Strawberry
raresSettingsSection:AddToggle("StrawberryToggle", {
	Title = "Strawberry",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Strawberry")
		else
			local index = table.find(vitaly.vars.rares, "Strawberry")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Swirled Wax
raresSettingsSection:AddToggle("Swirled WaxToggle", {
	Title = "Swirled Wax",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Swirled Wax")
		else
			local index = table.find(vitaly.vars.rares, "Swirled Wax")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Sunflower Seed
raresSettingsSection:AddToggle("Sunflower SeedToggle", {
	Title = "Sunflower Seed",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Sunflower Seed")
		else
			local index = table.find(vitaly.vars.rares, "Sunflower Seed")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})
-- Toggle: Ticket
raresSettingsSection:AddToggle("TicketToggle", {
	Title = "Ticket",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Ticket")
		else
			local index = table.find(vitaly.vars.rares, "Ticket")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Treat
raresSettingsSection:AddToggle("TreatToggle", {
	Title = "Treat",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Treat")
		else
			local index = table.find(vitaly.vars.rares, "Treat")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Whirligig
raresSettingsSection:AddToggle("WhirligigToggle", {
	Title = "Whirligig",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Whirligig")
		else
			local index = table.find(vitaly.vars.rares, "Whirligig")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Loaded Dice
raresSettingsSection:AddToggle("Loaded DiceToggle", {
	Title = "Loaded Dice",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Loaded Dice")
		else
			local index = table.find(vitaly.vars.rares, "Loaded Dice")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Toggle: Smooth Dice
raresSettingsSection:AddToggle("Smooth DiceToggle", {
	Title = "Smooth Dice",
	Default = false,
	Callback = function(State)
		if State then
			table.insert(vitaly.vars.rares, "Smooth Dice")
		else
			local index = table.find(vitaly.vars.rares, "Smooth Dice")
			if index then
				table.remove(vitaly.vars.rares, index)
			end
		end
	end
})

-- Auto Dispensers
for i, v in pairs(AllToysTable.dispensersTable) do
	settingsTab:AddToggle(i, {
		Title = "Auto " .. v,
		Path = {"autodispensersettings", i},
		Default = true,
	})
end

-- Auto Boosters
for i, v in pairs(AllToysTable.boostersTable) do
	settingsTab:AddToggle(i, {
		Title = "Auto " .. v,
		Path = {"autoboostersettings", i},
		Default = true,
	})
end




local Webhook = Tabs.Webhook

do
	local useWebhookToggle = Webhook:AddToggle("UseWebhook", {Title = "Use webhook", Default = false })
	useWebhookToggle:OnChanged(function(State)
		print("Use webhook:", State)
		if State then
			Tasks:Add("Webhook", function()
				while task.wait(1) do
					if tick() - temptable.lastWebhookSent > vitaly.webhookSettings.messageFrequency * 60 then
						sendHourlyWebhook()
					end
				end
			end, true)
		else
			if Tasks:Get("Webhook") then Tasks:Cancel("Webhook") end
		end
	end)

	local messageFrequencySlider = Webhook:AddSlider("MessageFrequency", {
		Title = "Message frequency",
		Min = 1,
		Max = 120,
		Default = 30,
		Rounding = 1
	})
	messageFrequencySlider:OnChanged(function(Value)
		print("Message frequency:", Value)
		vitaly.webhookSettings.messageFrequency = Value
	end)

	Webhook:AddInput("WebhookUrl", {
		Title = "Webhook Url",
		Placeholder = "ex: https://discord.com/api/...",
		Default = "",
		Numeric = false,
		Finished = true,
		Callback = function(Value)
			print("Webhook Url:", Value)
			vitaly.webhookSettings.webhookUrl = Value
		end
	})

	Webhook:AddInput("DiscordUserId", {
		Title = "Discord User Id",
		Placeholder = "ex: 123456",
		Default = "",
		Numeric = false,
		Finished = true,
		Callback = function(Value)
			print("Discord User Id:", Value)
			vitaly.webhookSettings.discordId = Value
		end
	})

	Webhook:AddInput("WebhookColor", {
		Title = "Webhook Color",
		Placeholder = "ex: 0xfcdf03 or #fcdf03",
		Default = "",
		Numeric = false,
		Finished = true,
		Callback = function(Color)
			print("Webhook Color:", Color)
			local done = false
			if string.match(Color, "^".."0x") then 
				done = true
				vitaly.webhookSettings.webhookColor = Color
			end
			if not done then
				local newColor,_ = string.gsub(Color, "#", "0x") 
				if _ == 1 then
					vitaly.webhookSettings.webhookColor = newColor
				else
					api.notify("Macro V3 - v" .. temptable.version, "Invalid Color!", 2)
					api.notify("Macro V3 - v" .. temptable.version, "Make sure you're using Hex color.", 5)
				end
			end
		end
	})

	local pingUserToggle = Webhook:AddToggle("PingUser", {Title = "Ping discord id", Default = false })
	pingUserToggle:OnChanged(function(State)
		print("Ping discord id:", State)
		vitaly.webhookSettings.pingUser = State
	end)

	Webhook:AddButton({
		Title = "Test Webhook",
		Description = "",
		Callback = function()
			print("Test Webhook button pressed")
			sendHourlyWebhook(true)
		end
	})
end

Webhook:AddSection("Webhook Settings")

Webhook:AddToggle("showTotalHoney", {
	Title = "Show Total Honey",
	Path = {"webhookSettings", "showTotalHoney"},
	Default = false,
}):OnChanged(function(State)
	print("Show Total Honey:", State)
	vitaly.webhookSettings.showTotalHoney = State
end)

Webhook:AddToggle("showHoneyPerHour", {
	Title = "Show Honey Per Hour",
	Path = {"webhookSettings", "showHoneyPerHour"},
	Default = false,
}):OnChanged(function(State)
	vitaly.webhookSettings.showHoneyPerHour = State
end)

Webhook:AddToggle("showDailyHoney", {
	Title = "Show Daily Honey",
	Path = {"webhookSettings", "showDailyHoney"},
	Default = false,
}):OnChanged(function(State)
	vitaly.webhookSettings.showDailyHoney = State
end)

Webhook:AddToggle("showNectars", {
	Title = "Show Nectars",
	Path = {"webhookSettings", "showNectars"},
	Default = false,
}):OnChanged(function(State)
	vitaly.webhookSettings.showNectars = State
end)

Webhook:AddToggle("showPlanters", {
	Title = "Show Planters",
	Path = {"webhookSettings", "showPlanters"},
	Default = false,
}):OnChanged(function(State)
	vitaly.webhookSettings.showPlanters = State
end)

Webhook:AddToggle("onlyTruncated", {
	Title = "Truncated only",
	Path = {"webhookSettings", "onlyTruncated"},
	Default = false,
}):OnChanged(function(State)
	vitaly.webhookSettings.onlyTruncated = State
end)


local configTab = Tabs.Config

if scriptType == LPH_STRENC("Paid") then
	local premiumTab = Tabs.Premium

	if isBeesmas() then
		for i, v in pairs(AllToysTable.beesmasToysTable) do
			premiumTab:AddToggle(i, {
				Title = "Auto " .. v,
				Path = {"toggles", i},
				Default = true,
			}):OnChanged(function(State)
				vitaly.toggles[i] = State
			end)
		end
	end



	premiumTab:AddSection("TP To Rare")
	premiumTab:AddToggle("farmrares", {
		Title = "TP To Rare",
		Path = {"toggles", "farmrares"},
		Default = vitaly.toggles.farmrares,
	}):OnChanged(function(State)
		vitaly.toggles.farmrares = State
		print("farmrares changed to", State)
		if State then
			Tasks:Add("FarmRares", function()
				while task.wait() do
					if vitaly.toggles.farmrares then
						for k, v in next, temptable.tokenpath:GetChildren() do
							if v.CFrame.YVector.Y == 1 then
								if v.Transparency < 0.5 then
									local decal = v:FindFirstChildOfClass("Decal")
									for e, r in next, vitaly.vars.rares do
										local rare, rareError = getItemByName(tostring(r))
										local rareTexture = rare and rare.Icon
										if rareTexture and decal and v ~= nil and rareTexture == decal.Texture then
											local oldPos = api.humanoidrootpart().CFrame
											for i = 1, 5 do
												moveTo(v.Position)
												task.wait()
											end
											api.humanoidrootpart().CFrame = oldPos
										end
									end
								end
							end
						end
					end
				end
			end)
		else
			if Tasks:Get("FarmRares") then Tasks:Cancel("FarmRares") end
		end
	end)

	premiumTab:AddToggle("auto fire fly",{
		Title = 'Auto Farm Firefly',
		Default = getgenv().vitaly.toggles.autoFireFly,
		Callback = function(v)
			getgenv().vitaly.toggles.autoFireFly = v
			if v then
				count = 0
				spawn(function()
					while getgenv().vitaly.toggles.autoFireFly do
						local nearestFirefly = GetNearestFirefly()
						if nearestFirefly then
							temptable.stopEverything = true
							count = count + 1
							moveTo(nearestFirefly.Position)

						else
							temptable.stopEverything = false
						end
						wait()
					end
				end)
			end
		end
	})

	function GetNearestFirefly()
		local nearestFirefly = nil
		local nearestDistance = math.huge

		for _, v in pairs(game.Workspace.NPCBees:GetChildren()) do
			if v.Name == "Firefly" and v:FindFirstChild("BodyVelocity") and v.BodyVelocity.Velocity == Vector3.new(0, 0, 0) then
				local distance = (player.Character.HumanoidRootPart.Position - v.Position).magnitude
				if distance < nearestDistance then
					nearestDistance = distance
					nearestFirefly = v
				end
			end
		end

		return nearestFirefly
	end

end


if _G.debugging then
	warn("UI init done. waiting 5 seconds")
	task.wait(5)
end

if _G.debugging then
	warn("Calling functions")
end


Tasks:Add("Important Listeners", function() 
	while task.wait(1) do
		checkPuffshrooms()
		checkPopStar()

		temptable.isRBCActive = getClientStatCache("RoboChallenges", "ActiveChallenge") and true or false
		temptable.EquippedCollector = updateClientStatCache("EquippedCollector")
	end
end, true)

for i, v in pairs(Workspace.Particles:GetChildren()) do
	if v.Name:find("Vicious") then
		temptable.detected.vicious = true
	end
end

for i,instance in pairs(Workspace.Sprouts:GetChildren()) do
	if instance.Name == "Sprout" then
		local sproutRarity = sproutRarities[instance.Color]
		local sproutField = findField(instance.Position)
		local sproutId = math.round(tick()*10)/10
		local temp = Instance.new("StringValue",instance)
		temp.Name = "SproutId"
		temp.Value = sproutId
		if sproutRarity ~= "Moon" then
			temptable.sproutsTable[sproutId] = {Model = instance, Field = sproutField}
		end
	end
end


-- Listening
local Listeners = {}

table.insert(Listeners,Workspace.Particles.ChildAdded:Connect(function(instance)
	task.wait()
	if string.find(instance.Name, "Vicious") then
		temptable.detected.vicious = true

	elseif instance.Name == "Guiding Star" then 
		print("guiding added handler")

	elseif instance.Name == "WarningDisk" and instance.BrickColor == BrickColor.new("Lime green") then
		if instance.Size.X == 8 and true then
			if tick() - temptable.lastShowerRegistered < 0.05 then return end
			table.insert(temptable.showersTable, instance)
			temptable.lastShowerRegistered = tick()
		elseif instance.Size.X == 30 and true then
			if tick() - temptable.lastShowerRegistered < 0.05 then return end
			table.insert(temptable.coconutsTable, instance)
			temptable.lastShowerRegistered = tick()
		end
	end
end))

table.insert(Listeners,Workspace.Particles.ChildRemoved:Connect(function(instance)
	if string.find(instance.Name, "Vicious") then
		temptable.detected.vicious = false

	elseif instance.Name == "Guiding Star" then
		print("guiding removed handler")

	elseif instance.Name == "WarningDisk" and instance.BrickColor == BrickColor.new("Lime green") then
		if instance.Size.X == 8 and true then
			local index = table.find(temptable.showersTable, instance)
			if index then table.remove(temptable.showersTable, index) end
		elseif instance.Size.X == 30 and true then
			local index = table.find(temptable.coconutsTable, instance)
			if index then table.remove(temptable.coconutsTable, index) end
		end

	end
end))

table.insert(Listeners,Workspace.Sprouts.ChildAdded:Connect(function(instance)
	task.wait()
	if instance.Name ~= "Sprout" then return end
	local sproutRarity = sproutRarities[instance.Color]
	local sproutField = findField(instance.Position)
	-- print("Spawned sprout rarity:", sproutRarity)
	local sproutId = math.round(tick()*10)/10
	local temp = Instance.new("StringValue",instance)
	temp.Name = "SproutId"
	temp.Value = sproutId
	if sproutRarity ~= "Moon" then
		temptable.sproutsTable[sproutId] = {Model = instance, Field = sproutField}
	end
end))

table.insert(Listeners,Workspace.Sprouts.ChildRemoved:Connect(function(instance)
	task.wait()
	if instance.Name ~= "Sprout" then return end
	local sproutId = instance:FindFirstChild("SproutId")
	if sproutId then
		temptable.sproutsTable[sproutId.Value] = nil
	else
		-- warn("no sprout id :skull:")
	end
end))

table.insert(Listeners,Workspace.Monsters.ChildAdded:Connect(function(monster)
	task.wait()
	if monster.Name:find("Vicious") then
		local viciousOnField = findField(monster.HumanoidRootPart.Position)
		bssAlert("Vicious", monster.Name.." spawned on "..viciousOnField.Name)
	end
end))

table.insert(Listeners,Flowers.DescendantAdded:Connect(function(instance)
	task.wait()
	if instance.Name == "LeafBurst" then
		table.insert(temptable.leafTable, instance)
	elseif instance.Name == "Sparkles" then
		table.insert(temptable.sparklesTable, instance)
	end
end))

table.insert(Listeners,Flowers.DescendantRemoving:Connect(function(instance)
	task.wait()
	if instance.Name == "LeafBurst" then
		local index = table.find(temptable.leafTable, instance)
		if index then
			table.remove(temptable.leafTable, index)
		end
	elseif instance.Name == "Sparkles" then
		local index = table.find(temptable.sparklesTable, instance)
		if index then
			table.remove(temptable.sparklesTable, index)
		end
	end
end))

table.insert(Listeners,temptable.tokenpath.ChildAdded:Connect(function(token)
	task.wait()
	if token.Name == "C" then
		table.insert(temptable.tokensTable, token)
	end
end))

table.insert(Listeners,temptable.tokenpath.ChildRemoved:Connect(function(token)
	local tokenIndex = table.find(temptable.tokensTable, token)
	if tokenIndex then
		table.remove(temptable.tokensTable, tokenIndex)
	end
end))

task.spawn(function() 
	repeat task.wait(1) until Workspace:FindFirstChild("Balloons") and Workspace.Balloons:FindFirstChild("FieldBalloons")
	temptable.FieldBalloons = Workspace.Balloons.FieldBalloons
	table.insert(Listeners,Workspace.Balloons.FieldBalloons.ChildAdded:Connect(function(balloon) 
		task.wait()
		if balloon:FindFirstChild("PlayerName") and balloon.PlayerName.Value == player.Name then
			local balloonId = balloon.Name:gsub("Balloon", "")
			temptable.balloonsTable[tonumber(balloonId)] = balloon
		end
	end))
	table.insert(Listeners,Workspace.Balloons.FieldBalloons.ChildRemoved:Connect(function(balloon)
		if balloon:FindFirstChild("PlayerName") and balloon.PlayerName.Value == player.Name then
			local balloonId = balloon.Name:gsub("Balloon", "")
			if balloonId then
				temptable.balloonsTable[tonumber(balloonId)] = nil
			end
		end
	end))
end)

local whitelistedDupedTokens = {
	"1629547638",
	"5877939956"
}

task.spawn(function() 
	repeat task.wait(1) until Workspace:FindFirstChild("Camera") and Workspace.Camera:FindFirstChild("DupedTokens")
	table.insert(Listeners,Workspace.Camera.DupedTokens.ChildAdded:Connect(function(instance) 
		task.wait(.05)
		local texture = instance.FrontDecal.Texture
		local tokenId = tostring(tostring(texture):match("%d+"))
		pcall(function() appendfile("DupedTokens.txt", tostring(tokenId).."\n") end)
		if table.find(whitelistedDupedTokens, tokenId) then
			table.insert(temptable.dupedTokensTable, instance)
		end
	end))
	table.insert(Listeners,Workspace.Camera.DupedTokens.ChildRemoved:Connect(function(instance) 
		task.wait(.05)
		local index = table.find(temptable.dupedTokensTable, instance)
		if index then
			table.remove(temptable.dupedTokensTable, index)
		end
	end))
end)



player.Idled:Connect(function()
	VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
	task.wait(1)
	VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)

if _G.debugging then
	warn("Calling functions done. WaiTINg 5 Seconds")
	task.wait(5)
end

if _G.debugging then
	warn("Loading config")
end

-- Remove/Hide decorations
task.spawn(function() 
	for _, v in pairs(Workspace.Decorations.Misc:GetDescendants()) do
		if v.Parent.Name == "Mushroom" then
			v.CanCollide = false
			v.Transparency = 0.3
		end
	end
	for _,v in pairs(ReplicatedStorage.MonsterBarriers:GetChildren()) do
		v.CanCollide = false
	end
	for _,v in pairs(Workspace.Paths:GetChildren()) do
		v.CanCollide = false
	end
	for _, v in pairs(temptable.fieldDecosFolder:GetDescendants()) do
		if v:IsA("BasePart") then
			v.CanCollide = false
			v.Transparency = 0.3
		end
	end
	for _, v in pairs(Workspace.Decorations:GetDescendants()) do
		if v:IsA("BasePart") and
			(v.Parent.Name == "Bush" or v.Parent.Name == "Blue Flower") then
			v.CanCollide = false
			v.Transparency = 0.3
		end
	end
	Workspace.Gates["15 Bee Gate"].Frame.CanCollide = false
end)

function destroyBodyGyro()
	if not (player and player.Character and player.Character:FindFirstChild("UpperTorso")) then return end
	local characterTorso = player.Character:FindFirstChild("UpperTorso")

	local bodyGyro = characterTorso:FindFirstChildOfClass("BodyGyro")
	if bodyGyro then bodyGyro:Destroy() end
end

function lookAt(targetPos)
	if not (player and player.Character and player.Character:FindFirstChild("UpperTorso")) then return end
	local characterTorso = player.Character:FindFirstChild("UpperTorso")

	local bodyGyro = characterTorso:FindFirstChildOfClass("BodyGyro") or Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, math.huge, 0)
	bodyGyro.D = 10
	bodyGyro.P = 5000
	bodyGyro.CFrame = CFrame.new(characterTorso.CFrame.p, targetPos)
	bodyGyro.Parent = characterTorso
end

Tasks:Add("Auto Face", function() 
	while task.wait() do
		if not true or not (vitaly.autoFarmSettings.faceCenter or vitaly.autoFarmSettings.faceBalloons or vitaly.autoFarmSettings.faceFlames)
		then destroyBodyGyro() task.wait(0.5) continue end

		if not api.humanoidrootpart() or not player.Character then destroyBodyGyro() task.wait(1) continue end

		local characterTorso = player.Character:FindFirstChild("UpperTorso")

		local playerStandsOn = findField(api.humanoidrootpart().Position)
		if not playerStandsOn or not characterTorso then destroyBodyGyro() task.wait(0.1) continue end

		if vitaly.autoFarmSettings.faceCenter then
			lookAt(playerStandsOn.Position)
			continue
		end

		if vitaly.autoFarmSettings.faceBalloons then
			local bestBalloon = getBestFieldBalloon()
			if bestBalloon and bestBalloon:FindFirstChild("BalloonBody") then
				lookAt(bestBalloon.BalloonBody.Position)
			else
				destroyBodyGyro()
				print("mohaimen_afg on discord")
			end
			continue
		end

		if vitaly.autoFarmSettings.faceFlames then
			local pos = nil
			for i,v in pairs(game.Workspace.PlayerFlames:GetChildren()) do
				pcall(function() 
					if v:FindFirstChild("PF") and v.PF.Color.Keypoints[1].Value.G ~= 0 and (v.Position - torso.Position).magnitude < 20 then
						pos = v.Position
					end
				end)
				if pos then break end
			end
			if pos then
				lookAt(pos)
			else
				destroyBodyGyro()
			end
			continue
		end
	end
end, true)
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})

InterfaceManager:SetFolder("vitaly")
SaveManager:SetFolder("vitaly/bss")

InterfaceManager:BuildInterfaceSection(Tabs.Config)
SaveManager:BuildConfigSection(Tabs.Config)

Window:SelectTab(1)

SaveManager:LoadAutoloadConfig()
